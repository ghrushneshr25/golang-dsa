
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>backtracking: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">golang-dsa/backtracking/generateNCharStringFromK.go (100.0%)</option>
				
				<option value="file1">golang-dsa/backtracking/generateNbitString.go (100.0%)</option>
				
				<option value="file2">golang-dsa/common/compare.go (92.3%)</option>
				
				<option value="file3">golang-dsa/linkedlist/AddNumbersOfTwoLinkedList.go (100.0%)</option>
				
				<option value="file4">golang-dsa/linkedlist/ExchangeAdjacentNodes.go (100.0%)</option>
				
				<option value="file5">golang-dsa/linkedlist/ReverseKNodes.go (100.0%)</option>
				
				<option value="file6">golang-dsa/linkedlist/checkCycle.go (100.0%)</option>
				
				<option value="file7">golang-dsa/linkedlist/circularLinkedList.go (100.0%)</option>
				
				<option value="file8">golang-dsa/linkedlist/doubleLinkedList.go (100.0%)</option>
				
				<option value="file9">golang-dsa/linkedlist/findBeginOfLoop.go (100.0%)</option>
				
				<option value="file10">golang-dsa/linkedlist/findFractionalNode.go (100.0%)</option>
				
				<option value="file11">golang-dsa/linkedlist/findLengthOfLoop.go (100.0%)</option>
				
				<option value="file12">golang-dsa/linkedlist/findModularNode.go (100.0%)</option>
				
				<option value="file13">golang-dsa/linkedlist/findModularNodeFromEnd.go (93.3%)</option>
				
				<option value="file14">golang-dsa/linkedlist/insertANodeInSortedLL.go (100.0%)</option>
				
				<option value="file15">golang-dsa/linkedlist/intersectionOfTwoLinkedList.go (100.0%)</option>
				
				<option value="file16">golang-dsa/linkedlist/isLinkedListEven.go (100.0%)</option>
				
				<option value="file17">golang-dsa/linkedlist/josephuscircle.go (100.0%)</option>
				
				<option value="file18">golang-dsa/linkedlist/mergeTwoSortedLinkedList.go (100.0%)</option>
				
				<option value="file19">golang-dsa/linkedlist/middleOfLinkedList.go (100.0%)</option>
				
				<option value="file20">golang-dsa/linkedlist/nthNodeFromEnd.go (100.0%)</option>
				
				<option value="file21">golang-dsa/linkedlist/palindromeLinkedList.go (100.0%)</option>
				
				<option value="file22">golang-dsa/linkedlist/partitionByK.go (100.0%)</option>
				
				<option value="file23">golang-dsa/linkedlist/removeDuplicatesFromUnorderedList.go (100.0%)</option>
				
				<option value="file24">golang-dsa/linkedlist/reorder.go (100.0%)</option>
				
				<option value="file25">golang-dsa/linkedlist/reverseLinkedListInPairs.go (100.0%)</option>
				
				<option value="file26">golang-dsa/linkedlist/reverseSingleLinkedList.go (100.0%)</option>
				
				<option value="file27">golang-dsa/linkedlist/rotateByK.go (100.0%)</option>
				
				<option value="file28">golang-dsa/linkedlist/singleLinkedList.go (100.0%)</option>
				
				<option value="file29">golang-dsa/linkedlist/splitCircularLinkedList.go (100.0%)</option>
				
				<option value="file30">golang-dsa/linkedlist/unrolledLinkedList.go (96.5%)</option>
				
				<option value="file31">golang-dsa/recursion/sortedArray.go (100.0%)</option>
				
				<option value="file32">golang-dsa/recursion/towerOfHanoi.go (100.0%)</option>
				
				<option value="file33">golang-dsa/stack/admissibleString.go (100.0%)</option>
				
				<option value="file34">golang-dsa/stack/balanceParanthesis.go (100.0%)</option>
				
				<option value="file35">golang-dsa/stack/dynamicArrayStackImplementation.go (100.0%)</option>
				
				<option value="file36">golang-dsa/stack/findingOfSpans.go (100.0%)</option>
				
				<option value="file37">golang-dsa/stack/getMinimum.go (100.0%)</option>
				
				<option value="file38">golang-dsa/stack/infixToPostFix.go (100.0%)</option>
				
				<option value="file39">golang-dsa/stack/isPallindromeWithX.go (100.0%)</option>
				
				<option value="file40">golang-dsa/stack/linkedListStack.go (100.0%)</option>
				
				<option value="file41">golang-dsa/stack/postFixEvaluation.go (100.0%)</option>
				
				<option value="file42">golang-dsa/stack/simpleArrayImplementation.go (100.0%)</option>
				
				<option value="file43">golang-dsa/stack/stackReversal.go (100.0%)</option>
				
				<option value="file44">golang-dsa/stack/twoStackWithOneArray.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
        Problem 4: Generate all the strings of length n drawn from 0...k−1

        Using Subtraction and Conquer Master theorem, we get: T(n)= O(݇k^n)
*/

package backtracking

import (
        "fmt"
        "strings"
)

type NCharStringFromK struct {
        PoolSize     int // refers to K
        Length       int
        Combinations []string
        Current      []int
}

func NewNCharStringFromK(poolSize, length int) *NCharStringFromK <span class="cov8" title="1">{
        field := &amp;NCharStringFromK{}
        field.PoolSize = poolSize
        field.Length = length
        field.Current = make([]int, length)
        field.Combinations = []string{}
        return field
}</span>

func (nchar *NCharStringFromK) Execute() <span class="cov8" title="1">{
        nchar.Recursion(nchar.Length - 1) // since indexing starts from zero
}</span>

func (nchar *NCharStringFromK) Recursion(index int) <span class="cov8" title="1">{
        if index &lt; 0 </span><span class="cov8" title="1">{
                nchar.generate()
                return
        }</span>

        <span class="cov8" title="1">for j := 0; j &lt; nchar.PoolSize; j++ </span><span class="cov8" title="1">{
                nchar.Current[index] = j
                nchar.Recursion(index - 1)
        }</span>
}

func (nchar *NCharStringFromK) generate() <span class="cov8" title="1">{
        strs := make([]string, nchar.Length)
        for i, v := range nchar.Current </span><span class="cov8" title="1">{
                strs[i] = fmt.Sprintf("%d", v)
        }</span>
        <span class="cov8" title="1">result := strings.Join(strs, "")
        if len(result) &gt; 0 </span><span class="cov8" title="1">{
                nchar.Combinations = append(nchar.Combinations, result)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
        Problem 3: Generate all the strings of ݊n bits. Assume A[0...n-1] is an array of size ݊n.

        Using Subtraction and Conquer Master theorem, we get T(n)=O(2^n).
        This means the algorithm for generating bit-strings is optimal.
*/

package backtracking

import "strings"

type NBitString struct {
        Size         int
        Combinations []string
        Content      []string
}

func (nbit *NBitString) Recursion(current int) <span class="cov8" title="1">{
        if current &lt;= 0 </span><span class="cov8" title="1">{
                if len(nbit.Content) &gt; 0 </span><span class="cov8" title="1">{
                        nbit.Combinations = append(nbit.Combinations, strings.Join(nbit.Content, ""))
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">nbit.Content[current-1] = "0"
        nbit.Recursion(current - 1)
        nbit.Content[current-1] = "1"
        nbit.Recursion(current - 1)</span>
}

func NewNBitString(size int) *NBitString <span class="cov8" title="1">{
        nbitString := &amp;NBitString{}
        nbitString.Size = size
        nbitString.Content = make([]string, size)
        return nbitString
}</span>

func (nbit *NBitString) Execute() <span class="cov8" title="1">{
        nbit.Recursion(nbit.Size)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package common

func CompareStringArrays(arr1, arr2 []string) bool <span class="cov8" title="1">{
        if len(arr1) != len(arr2) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">freq := make(map[string]int)
        for _, item := range arr1 </span><span class="cov8" title="1">{
                freq[item]++
        }</span>
        <span class="cov8" title="1">for _, item := range arr2 </span><span class="cov8" title="1">{
                freq[item]--
                if freq[item] &lt; 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for _, count := range freq </span><span class="cov8" title="1">{
                if count != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
        Problem-58
                You are given two linked lists representing two non-negative numbers.
                The digits are stored in reverse order and each of their nodes contain a single digit.
                Add the two numbers and return it as a linked list.
                Example:
                        3-&gt;4-&gt;3 + 5-&gt;6-&gt;4 = 8-&gt;0-&gt;8

*/

package linkedlist

type AddNumbersOfTwoLinkedList struct {
        headOne *SingleLinkedList
        headTwo *SingleLinkedList
        Result  []int
}

func NewAddNumbersOfTwoLinkedList(valOne, valTwo []int) *AddNumbersOfTwoLinkedList <span class="cov8" title="1">{
        return &amp;AddNumbersOfTwoLinkedList{
                headOne: ConvertArrayToSingleLinkedList(valOne),
                headTwo: ConvertArrayToSingleLinkedList(valTwo),
        }
}</span>

func (obj *AddNumbersOfTwoLinkedList) addNumbersOfTwoLinkedList(headOne, headTwo *SingleLinkedList) *SingleLinkedList <span class="cov8" title="1">{
        if headOne == nil </span><span class="cov8" title="1">{
                return headTwo
        }</span>

        <span class="cov8" title="1">if headTwo == nil </span><span class="cov8" title="1">{
                return headOne
        }</span>

        <span class="cov8" title="1">result := &amp;SingleLinkedList{}
        current := result

        carryForward := 0

        for headOne != nil &amp;&amp; headTwo != nil </span><span class="cov8" title="1">{
                sum := headOne.GetData() + headTwo.GetData() + carryForward
                carryForward = sum / 10
                sum = sum % 10
                current.SetNext(NewSingleLinkedList(sum))
                current = current.GetNext()
                headOne = headOne.GetNext()
                headTwo = headTwo.GetNext()
        }</span>

        <span class="cov8" title="1">if headOne != nil </span><span class="cov8" title="1">{
                if carryForward != 0 </span><span class="cov8" title="1">{
                        current.SetNext(obj.addNumbersOfTwoLinkedList(headOne, NewSingleLinkedList(carryForward)))
                }</span> else<span class="cov8" title="1"> {
                        current.SetNext(headOne)
                }</span>
        } else<span class="cov8" title="1"> if headTwo != nil </span><span class="cov8" title="1">{
                if carryForward != 0 </span><span class="cov8" title="1">{
                        current.SetNext(obj.addNumbersOfTwoLinkedList(headTwo, NewSingleLinkedList(carryForward)))
                }</span> else<span class="cov8" title="1"> {
                        current.SetNext(headTwo)
                }</span>
        } else<span class="cov8" title="1"> if carryForward != 0 </span><span class="cov8" title="1">{
                current.SetNext(NewSingleLinkedList(carryForward))
        }</span>

        <span class="cov8" title="1">return result.GetNext()</span>
}

func (obj *AddNumbersOfTwoLinkedList) Execute() <span class="cov8" title="1">{
        result := obj.addNumbersOfTwoLinkedList(obj.headOne, obj.headTwo)
        obj.Result = ConvertSingleLinkedListToArray(result)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
        Problem-40 Exchange the adjacent elements in a link list.
        Time Complexity: O(n)
        Space Complexity: O(1)
*/

package linkedlist

type ExchangeAdjacentNodes struct {
        head   *SingleLinkedList
        Result []int
}

func NewExchangeAdjacentNodes(val []int) *ExchangeAdjacentNodes <span class="cov8" title="1">{
        return &amp;ExchangeAdjacentNodes{
                head: ConvertArrayToSingleLinkedList(val),
        }
}</span>

func (ean *ExchangeAdjacentNodes) ExchangeAdjacentNodes() <span class="cov8" title="1">{
        temp := &amp;SingleLinkedList{}
        temp.SetNext(ean.head)

        previous, current := temp, ean.head
        for current != nil &amp;&amp; current.GetNext() != nil </span><span class="cov8" title="1">{
                tmp := current.GetNext().GetNext()
                current.GetNext().SetNext(previous.GetNext())
                previous.SetNext(current.GetNext())
                current.SetNext(tmp)
                previous = current
                current = previous.GetNext()
        }</span>

        <span class="cov8" title="1">ean.head = temp.GetNext()</span>
}

func (ean *ExchangeAdjacentNodes) Execute() <span class="cov8" title="1">{
        ean.ExchangeAdjacentNodes()
        ean.Result = ConvertSingleLinkedListToArray(ean.head)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
        For a given K value (K&gt;0) reverse blocks of K nodes in a list.
         Example: Input: 1 2 3 4 5 6 7 8 9 10,

        Output for different K values:
                 For K = 2 =&gt; 2 1 4 3 6 5 8 7 10 9
                For K = 3 =&gt; 3 2 1 6 5 4 9 8 7 10
                For K = 4 =&gt; 4 3 2 1 8 7 6 5 9 10

        This is an extension of swapping nodes in a linked list.
        1) Check if remaining list has K nodes.
                a. If yes get the pointer of K+1 th  node.
                b. Else return.
        2) Reverse first K nodes.
        3) Set next of last node (after reversal) to K+1  node.
        4) Move to K+1  node.
        5) Go to step 1.
        6) K−1  node of first K nodes becomes the new head if available. Otherwise, we can return the head.

*/

package linkedlist

type ReverseKNodes struct {
        head   *SingleLinkedList
        k      int
        Result []int
}

func NewReverseKNodes(val []int, k int) *ReverseKNodes <span class="cov8" title="1">{
        return &amp;ReverseKNodes{
                head: ConvertArrayToSingleLinkedList(val),
                k:    k,
        }
}</span>

func (rkn *ReverseKNodes) ReverseNodes() <span class="cov8" title="1">{
        rkn.head = rkn.reverseKNodes(rkn.head, rkn.k)
}</span>

func (rkn *ReverseKNodes) reverseKNodes(head *SingleLinkedList, k int) *SingleLinkedList <span class="cov8" title="1">{
        current := head
        var prev, next *SingleLinkedList
        count := 0

        // Check if there are at least k nodes left to reverse
        temp := head
        for i := 0; i &lt; k; i++ </span><span class="cov8" title="1">{
                if temp == nil </span><span class="cov8" title="1">{
                        return head
                }</span>
                <span class="cov8" title="1">temp = temp.GetNext()</span>
        }

        // Reverse first k nodes of the linked list
        <span class="cov8" title="1">for current != nil &amp;&amp; count &lt; k </span><span class="cov8" title="1">{
                next = current.GetNext()
                current.SetNext(prev)
                prev = current
                current = next
                count++
        }</span>

        // next is now pointing to (k+1)th node
        <span class="cov8" title="1">if next != nil </span><span class="cov8" title="1">{
                head.SetNext(rkn.reverseKNodes(next, k))
        }</span>

        // prev is now the head of the reversed list
        <span class="cov8" title="1">return prev</span>
}

func (rkn *ReverseKNodes) Execute() <span class="cov8" title="1">{
        rkn.ReverseNodes()
        rkn.Result = ConvertSingleLinkedListToArray(rkn.head)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
        Problem-7: Check whether the given linked list is either NULL-terminated or ends in a cycle (cyclic)
        Problem 8: --------------""-----------------------
        Problem 9: --------------""-----------------------
        Problem 10:  ------------""-----------------------
        Problem 11:  We are given a pointer to the first element of a linked list L.
                                There are two possibilities for L it either ends (snake) or 
                                its last element points back to one of the earlier elements in the list (snail). 
                                Give an algorithm that tests whether a given list is a snake or a snail.
*/

package linkedlist

type CheckCycle struct {
        Head   *SingleLinkedList
        Result bool
}

func NewCheckCycle(head *SingleLinkedList) *CheckCycle <span class="cov8" title="1">{
        return &amp;CheckCycle{
                Head: head,
        }
}</span>

func (cc *CheckCycle) Execute(methodName string) <span class="cov8" title="1">{
        methods := map[string]func() bool{
                "HashMapMethod":    cc.HashMapMethod,
                "TwoPointerMethod": cc.TwoPointerMethod,
        }
        cc.Result = methods[methodName]()
}</span>

/*
        Algorithm:
                - Traverse the linked list nodes one by one.
                - Check if the address of the node is available in the hash table or not.
                - If it is already available in the hash table, that indicates that we are visiting the node that was already visited. This is possible only if
                        the given linked list has a loop in it.
                - If the address of the node is not available in the hash table, insert that node’s address into the hash table.
                - Continue this process until we reach the end of the linked list ݎ݋ we find the loop.

        Time Complexity: O(n) for scanning the linked list
        Space Complexity: O(n)for hash table.
*/

func (cc *CheckCycle) HashMapMethod() bool <span class="cov8" title="1">{
        hashMap := map[*SingleLinkedList]bool{}
        current := cc.Head
        for current != nil </span><span class="cov8" title="1">{
                if _, ok := hashMap[current]; ok </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">hashMap[current] = true
                current = current.GetNext()</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (cc *CheckCycle) TwoPointerMethod() bool <span class="cov8" title="1">{
        fastPtr := cc.Head
        slowPtr := cc.Head

        for fastPtr != nil &amp;&amp; fastPtr.GetNext() != nil </span><span class="cov8" title="1">{
                fastPtr = fastPtr.GetNext().GetNext()
                slowPtr = slowPtr.GetNext()
                if fastPtr == slowPtr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package linkedlist

import "fmt"

type CircularLinkedList struct {
        data int
        next *CircularLinkedList
}

func NewCircularLinkedList(data int, next *CircularLinkedList) *CircularLinkedList <span class="cov8" title="1">{
        return &amp;CircularLinkedList{
                data: data,
                next: next,
        }
}</span>

func (cll *CircularLinkedList) GetData() int <span class="cov8" title="1">{
        return cll.data
}</span>

func (cll *CircularLinkedList) SetData(data int) <span class="cov8" title="1">{
        cll.data = data
}</span>

func (cll *CircularLinkedList) GetNext() *CircularLinkedList <span class="cov8" title="1">{
        return cll.next
}</span>

func (cll *CircularLinkedList) SetNext(next *CircularLinkedList) <span class="cov8" title="1">{
        cll.next = next
}</span>

func GetCircularLinkedListLength(cll *CircularLinkedList) int <span class="cov8" title="1">{
        length := 0
        if cll == nil </span><span class="cov8" title="1">{
                return length
        }</span>
        <span class="cov8" title="1">length = 1
        temp := cll.GetNext()
        for ; temp != cll; temp = temp.GetNext() </span><span class="cov8" title="1">{
                length = length + 1
        }</span>
        <span class="cov8" title="1">return length</span>
}

func PrintContentOfCircularLinkedList(cll *CircularLinkedList) (data string) <span class="cov8" title="1">{
        if cll == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">data = fmt.Sprintf("%v", cll.GetData())
        temp := cll.GetNext()
        for temp != cll </span><span class="cov8" title="1">{
                data = fmt.Sprintf("%v %v", data, temp.GetData())
                temp = temp.GetNext()
        }</span>
        <span class="cov8" title="1">return</span>
}

func InsertAtEndOfCircularLinkedList(head **CircularLinkedList, data int) <span class="cov8" title="1">{
        newNode := NewCircularLinkedList(data, nil)
        newNode.SetNext(newNode)
        if *head == nil </span><span class="cov8" title="1">{
                *head = newNode
                return
        }</span>

        <span class="cov8" title="1">temp := *head
        for temp.GetNext() != *head </span><span class="cov8" title="1">{
                temp = temp.GetNext()
        }</span>
        <span class="cov8" title="1">temp.SetNext(newNode)
        newNode.SetNext(*head)</span>
}

func InsertAtFrontOfCircularLinkedList(head **CircularLinkedList, data int) <span class="cov8" title="1">{
        newNode := NewCircularLinkedList(data, nil)
        newNode.SetNext(newNode)
        if *head == nil </span><span class="cov8" title="1">{
                *head = newNode
                return
        }</span>
        <span class="cov8" title="1">temp := *head
        for temp.GetNext() != *head </span><span class="cov8" title="1">{
                temp = temp.GetNext()
        }</span>
        <span class="cov8" title="1">temp.SetNext(newNode)
        newNode.SetNext(*head)
        *head = newNode</span>
}

func DeleteLastNodeOfCircularLinkedList(head **CircularLinkedList) <span class="cov8" title="1">{
        if *head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">temp := *head
        if temp.GetNext() == *head </span><span class="cov8" title="1">{
                *head = nil
                return
        }</span>

        <span class="cov8" title="1">for temp.GetNext().GetNext() != *head </span><span class="cov8" title="1">{
                temp = temp.GetNext()
        }</span>
        <span class="cov8" title="1">temp.SetNext(*head)</span>
}

func DeleteFirstNodeOfCircularLinkedList(head **CircularLinkedList) <span class="cov8" title="1">{
        if *head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">temp := *head
        if temp.GetNext() == *head </span><span class="cov8" title="1">{
                *head = nil
                return
        }</span>

        <span class="cov8" title="1">for temp.GetNext() != *head </span><span class="cov8" title="1">{
                temp = temp.GetNext()
        }</span>
        <span class="cov8" title="1">temp.SetNext((*head).GetNext())
        *head = (*head).GetNext()</span>
}

func ConvertArrayToCircularLinkedList(arr []int) *CircularLinkedList <span class="cov8" title="1">{
        var head *CircularLinkedList
        for _, v := range arr </span><span class="cov8" title="1">{
                InsertAtEndOfCircularLinkedList(&amp;head, v)
        }</span>
        <span class="cov8" title="1">return head</span>
}

func ConvertCircularLinkedListToArray(head *CircularLinkedList) []int <span class="cov8" title="1">{
        if head == nil </span><span class="cov8" title="1">{
                return []int{}
        }</span>
        <span class="cov8" title="1">temp := head
        var arr []int
        for </span><span class="cov8" title="1">{
                arr = append(arr, temp.GetData())
                temp = temp.GetNext()
                if temp == head </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package linkedlist

type DoubleLinkedList struct {
        data int
        next *DoubleLinkedList
        prev *DoubleLinkedList
}

func NewDoubleLinkedList(data int, next, prev *DoubleLinkedList) *DoubleLinkedList <span class="cov8" title="1">{
        return &amp;DoubleLinkedList{
                data: data,
                next: next,
                prev: prev,
        }
}</span>

func (dll *DoubleLinkedList) GetData() int <span class="cov8" title="1">{
        return dll.data
}</span>

func (dll *DoubleLinkedList) SetData(data int) <span class="cov8" title="1">{
        dll.data = data
}</span>

func (dll *DoubleLinkedList) GetPrev() *DoubleLinkedList <span class="cov8" title="1">{
        return dll.prev
}</span>

func (dll *DoubleLinkedList) SetPrev(prev *DoubleLinkedList) <span class="cov8" title="1">{
        dll.prev = prev
}</span>

func (dll *DoubleLinkedList) GetNext() *DoubleLinkedList <span class="cov8" title="1">{
        return dll.next
}</span>

func (dll *DoubleLinkedList) SetNext(next *DoubleLinkedList) <span class="cov8" title="1">{
        dll.next = next
}</span>

func GetDoubleLinkedListLength(head *DoubleLinkedList) int <span class="cov8" title="1">{
        var length int

        temp := head
        for temp != nil </span><span class="cov8" title="1">{
                length++
                temp = temp.GetNext()
        }</span>

        <span class="cov8" title="1">return length</span>
}

func InsertAtStartDoubleLL(head **DoubleLinkedList, data int) <span class="cov8" title="1">{
        newNode := NewDoubleLinkedList(data, *head, nil)
        if *head != nil </span><span class="cov8" title="1">{
                (*head).SetPrev(newNode)
        }</span>
        <span class="cov8" title="1">*head = newNode</span>
}

func InsertAtEndDoubleLL(head **DoubleLinkedList, data int) <span class="cov8" title="1">{
        newNode := NewDoubleLinkedList(data, nil, nil)
        if *head == nil </span><span class="cov8" title="1">{
                *head = newNode
                return
        }</span>

        <span class="cov8" title="1">temp := *head

        for temp.GetNext() != nil </span><span class="cov8" title="1">{
                temp = temp.GetNext()
        }</span>
        <span class="cov8" title="1">temp.SetNext(newNode)
        newNode.SetPrev(temp)</span>
}

func InsertAtPositionOfDoubleLL(head **DoubleLinkedList, data, position int) <span class="cov8" title="1">{
        if position == 0 </span><span class="cov8" title="1">{
                InsertAtStartDoubleLL(head, data)
                return
        }</span>

        <span class="cov8" title="1">newNode := NewDoubleLinkedList(data, nil, nil)
        temp := *head

        for i := 0; i &lt; position-1 &amp;&amp; temp != nil; i++ </span><span class="cov8" title="1">{
                temp = temp.GetNext()
        }</span>

        <span class="cov8" title="1">if temp == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">newNode.SetNext(temp.GetNext())
        newNode.SetPrev(temp)
        if temp.GetNext() != nil </span><span class="cov8" title="1">{
                temp.GetNext().SetPrev(newNode)
        }</span>
        <span class="cov8" title="1">temp.SetNext(newNode)</span>
}

func DeleteAtStartOfDoubleLL(head **DoubleLinkedList) <span class="cov8" title="1">{
        if *head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">*head = (*head).GetNext()
        if *head != nil </span><span class="cov8" title="1">{
                (*head).SetPrev(nil)
        }</span>
}

func DeleteAtEndOfDoubleLL(head **DoubleLinkedList) <span class="cov8" title="1">{
        if *head == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">temp := *head
        for temp.GetNext() != nil </span><span class="cov8" title="1">{
                temp = temp.GetNext()
        }</span>

        <span class="cov8" title="1">if temp.GetPrev() != nil </span><span class="cov8" title="1">{
                temp.GetPrev().SetNext(nil)
        }</span> else<span class="cov8" title="1"> {
                *head = nil
        }</span>
}

func DeleteAtPositionOfDoubleLL(head **DoubleLinkedList, position int) <span class="cov8" title="1">{
        if position == 0 </span><span class="cov8" title="1">{
                DeleteAtStartOfDoubleLL(head)
                return
        }</span>

        <span class="cov8" title="1">temp := *head
        for i := 0; i &lt; position &amp;&amp; temp != nil; i++ </span><span class="cov8" title="1">{
                temp = temp.GetNext()
        }</span>

        <span class="cov8" title="1">if temp == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if temp.GetPrev() != nil </span><span class="cov8" title="1">{
                temp.GetPrev().SetNext(temp.GetNext())
        }</span>
        <span class="cov8" title="1">if temp.GetNext() != nil </span><span class="cov8" title="1">{
                temp.GetNext().SetPrev(temp.GetPrev())
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
        Problem 12: Check whether the given linked list is NULL-terminated or not.
                                If there is a cycle find the start node of the loop.
*/

package linkedlist

type FindBeginOfLoop struct {
        Head   *SingleLinkedList
        Result int
}

func NewFindBeginOfLoop(head *SingleLinkedList) *FindBeginOfLoop <span class="cov8" title="1">{
        return &amp;FindBeginOfLoop{
                Head: head,
        }
}</span>

/*
        Time Complexity: O(n).
        Space Complexity: O(1).
*/

func (fbl *FindBeginOfLoop) FloydCycle() int <span class="cov8" title="1">{
        fastPtr := fbl.Head
        slowPtr := fbl.Head
        var loopExists bool
        for fastPtr != nil &amp;&amp; fastPtr.GetNext() != nil </span><span class="cov8" title="1">{
                fastPtr = fastPtr.GetNext().GetNext()
                slowPtr = slowPtr.GetNext()
                if fastPtr == slowPtr </span><span class="cov8" title="1">{
                        loopExists = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if loopExists </span><span class="cov8" title="1">{
                slowPtr = fbl.Head
                for slowPtr != fastPtr </span><span class="cov8" title="1">{
                        slowPtr = slowPtr.GetNext()
                        fastPtr = fastPtr.GetNext()
                }</span>
                <span class="cov8" title="1">return slowPtr.GetData()</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (fbl *FindBeginOfLoop) Execute() <span class="cov8" title="1">{
        fbl.Result = fbl.FloydCycle()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Problem-48
        Find fractional node:
        Given a singly linked list, write a function to find the n/k th element, where n is the number of elements in the list.
*/

package linkedlist

type FindFractionalNode struct {
        head   *SingleLinkedList
        k      int
        Result int
}

func NewFindFractionalNode(val []int, k int) *FindFractionalNode <span class="cov8" title="1">{
        return &amp;FindFractionalNode{
                head: ConvertArrayToSingleLinkedList(val),
                k:    k,
        }
}</span>

func (obj *FindFractionalNode) FindFractionalNode() int <span class="cov8" title="1">{
        var fractionalNode *SingleLinkedList
        if obj.k &lt;= 0 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">i := 0
        temp := obj.head
        for temp != nil </span><span class="cov8" title="1">{
                if i%obj.k == 0 </span><span class="cov8" title="1">{
                        if fractionalNode == nil </span><span class="cov8" title="1">{
                                fractionalNode = obj.head
                        }</span> else<span class="cov8" title="1"> {
                                fractionalNode = fractionalNode.GetNext()
                        }</span>
                }
                <span class="cov8" title="1">i++
                temp = temp.GetNext()
                if temp == nil </span><span class="cov8" title="1">{
                        if i%obj.k == 0 &amp;&amp; fractionalNode != nil </span><span class="cov8" title="1">{
                                fractionalNode = fractionalNode.GetNext()
                        }</span>
                }
        }

        <span class="cov8" title="1">return fractionalNode.GetData()</span>
}

func (obj *FindFractionalNode) Execute() <span class="cov8" title="1">{
        obj.Result = obj.FindFractionalNode()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
        Problem 15: Check whether the given linked list is NULL-terminated.
                                If there is a cycle, find the length of the loop.
*/

package linkedlist

type FindLengthOfLoop struct {
        Head   *SingleLinkedList
        Result int
}

func NewFindLengthOfLoop(head *SingleLinkedList) *FindLengthOfLoop <span class="cov8" title="1">{
        return &amp;FindLengthOfLoop{
                Head: head,
        }
}</span>

func (fll *FindLengthOfLoop) FloydCycle() int <span class="cov8" title="1">{
        fastPtr := fll.Head
        slowPtr := fll.Head
        var loopExists bool
        for fastPtr != nil &amp;&amp; fastPtr.GetNext() != nil </span><span class="cov8" title="1">{
                fastPtr = fastPtr.GetNext().GetNext()
                slowPtr = slowPtr.GetNext()
                if fastPtr == slowPtr </span><span class="cov8" title="1">{
                        loopExists = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if loopExists </span><span class="cov8" title="1">{
                count := 1
                fastPtr = fastPtr.GetNext()
                for slowPtr != fastPtr </span><span class="cov8" title="1">{
                        fastPtr = fastPtr.GetNext()
                        count++
                }</span>
                <span class="cov8" title="1">return count</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (fll *FindLengthOfLoop) Execute() <span class="cov8" title="1">{
        fll.Result = fll.FloydCycle()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Problem-47
        Find modular node: Given a singly linked list, write a function to find the last element from the beginning whose n % k == 0,
        where n is the number of elements in the list and k is an integer constant. For example, if n = 19 and k = 3 then we should return
        18th node.

        Time Complexity  : O(n)
        Space Complexity : O(1)
*/

package linkedlist

type FindModularNode struct {
        head   *SingleLinkedList
        k      int
        Result int
}

func NewFindModularNode(val []int, k int) *FindModularNode <span class="cov8" title="1">{
        return &amp;FindModularNode{
                head: ConvertArrayToSingleLinkedList(val),
                k:    k,
        }
}</span>

func (obj *FindModularNode) FindModularNode() int <span class="cov8" title="1">{
        var modularNode *SingleLinkedList
        if obj.k &lt;= 0 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">i := 0
        temp := obj.head
        for temp != nil </span><span class="cov8" title="1">{
                if i%obj.k == 0 </span><span class="cov8" title="1">{
                        modularNode = temp
                }</span>
                <span class="cov8" title="1">i++
                temp = temp.GetNext()</span>
        }
        <span class="cov8" title="1">return modularNode.GetData()</span>
}

func (obj *FindModularNode) Execute() <span class="cov8" title="1">{
        obj.Result = obj.FindModularNode()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Problem-48
        Find modular node from the end: Given a singly linked list,
        write a function to find the first element from the end whose
        n%k == 0, where n is the number of elements in the list and k is an integer constant.
        For example, if n=19 and k=3 then we should return 16 node.
*/

package linkedlist

type FindModularNodeFromEnd struct {
        head   *SingleLinkedList
        k      int
        Result int
}

func NewFindModularNodeFromEnd(val []int, k int) *FindModularNodeFromEnd <span class="cov8" title="1">{
        return &amp;FindModularNodeFromEnd{
                head: ConvertArrayToSingleLinkedList(val),
                k:    k,
        }
}</span>

func (obj *FindModularNodeFromEnd) FindModularNodeFromEnd() int <span class="cov8" title="1">{
        var modularNode *SingleLinkedList
        if obj.k &lt;= 0 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">temp := obj.head

        for i := 0; i &lt; obj.k; i++ </span><span class="cov8" title="1">{
                if temp != nil </span><span class="cov8" title="1">{
                        temp = temp.GetNext()
                }</span> else<span class="cov0" title="0"> {
                        return -1
                }</span>
        }

        <span class="cov8" title="1">modularNode = obj.head

        for temp != nil </span><span class="cov8" title="1">{
                temp = temp.GetNext()
                modularNode = modularNode.GetNext()
        }</span>
        <span class="cov8" title="1">return modularNode.GetData()</span>
}

func (obj *FindModularNodeFromEnd) Execute() <span class="cov8" title="1">{
        obj.Result = obj.FindModularNodeFromEnd()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
        Problem 16: Insert a node in a sorted linked list
*/

package linkedlist

type InsertANodeInSortedLL struct {
        Head   *SingleLinkedList
        Result []int
}

func NewInsertANodeInSortedLL(head *SingleLinkedList) *InsertANodeInSortedLL <span class="cov8" title="1">{
        return &amp;InsertANodeInSortedLL{
                Head: head,
        }
}</span>

/*
        Time Complexity: O(N)
        Space Complexity: O(1)
*/

func (sll *InsertANodeInSortedLL) InsertNode(data int) <span class="cov8" title="1">{
        newNode := NewSingleLinkedList(data)

        if sll.Head == nil </span><span class="cov8" title="1">{
                sll.Head = newNode
                return
        }</span>

        <span class="cov8" title="1">current := sll.Head
        var temp *SingleLinkedList
        for current != nil &amp;&amp; current.GetData() &lt; data </span><span class="cov8" title="1">{
                temp = current
                current = current.GetNext()
        }</span>

        <span class="cov8" title="1">newNode.SetNext(current)
        if temp != nil </span><span class="cov8" title="1">{
                temp.SetNext(newNode)
        }</span> else<span class="cov8" title="1"> {
                sll.Head = newNode
        }</span>
}

func (sll *InsertANodeInSortedLL) Execute(data int) <span class="cov8" title="1">{
        sll.InsertNode(data)
        sll.Result = []int{}
        current := sll.Head
        for current != nil </span><span class="cov8" title="1">{
                sll.Result = append(sll.Result, current.GetData())
                current = current.GetNext()
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package linkedlist

type IntersectionOfTwoLinkedList struct {
        headOne *SingleLinkedList
        headTwo *SingleLinkedList
        Result  int
}

func NewIntersectionOfTwoLinkedList(headOne, headTwo *SingleLinkedList) *IntersectionOfTwoLinkedList <span class="cov8" title="1">{
        return &amp;IntersectionOfTwoLinkedList{
                headOne: headOne,
                headTwo: headTwo,
                Result:  -1,
        }
}</span>

func (i2ll *IntersectionOfTwoLinkedList) BruteForceMethod() *SingleLinkedList <span class="cov8" title="1">{
        for headOne := i2ll.headOne; headOne != nil; headOne = headOne.GetNext() </span><span class="cov8" title="1">{
                for headTwo := i2ll.headTwo; headTwo != nil; headTwo = headTwo.GetNext() </span><span class="cov8" title="1">{
                        if headOne == headTwo </span><span class="cov8" title="1">{
                                return headOne
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (i2ll *IntersectionOfTwoLinkedList) StackMethod() *SingleLinkedList <span class="cov8" title="1">{
        stack1 := []*SingleLinkedList{}
        stack2 := []*SingleLinkedList{}

        for headOne := i2ll.headOne; headOne != nil; headOne = headOne.GetNext() </span><span class="cov8" title="1">{
                stack1 = append([]*SingleLinkedList{headOne}, stack1...)
        }</span>

        <span class="cov8" title="1">for headTwo := i2ll.headTwo; headTwo != nil; headTwo = headTwo.GetNext() </span><span class="cov8" title="1">{
                stack2 = append([]*SingleLinkedList{headTwo}, stack2...)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(stack1) &amp;&amp; i &lt; len(stack2); i++ </span><span class="cov8" title="1">{
                if stack1[i] != stack2[i] </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return stack1[i-1]</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (i2ll *IntersectionOfTwoLinkedList) TwoPointerMethod() *SingleLinkedList <span class="cov8" title="1">{
        var len1, len2, diff int
        currentOne, currentTwo := i2ll.headOne, i2ll.headTwo

        for currentOne != nil </span><span class="cov8" title="1">{
                len1++
                currentOne = currentOne.GetNext()
        }</span>

        <span class="cov8" title="1">for currentTwo != nil </span><span class="cov8" title="1">{
                len2++
                currentTwo = currentTwo.GetNext()
        }</span>

        <span class="cov8" title="1">if len2 &gt; len1 </span><span class="cov8" title="1">{
                currentOne, currentTwo = i2ll.headTwo, i2ll.headOne
                diff = len2 - len1
        }</span> else<span class="cov8" title="1"> {
                currentOne, currentTwo = i2ll.headOne, i2ll.headTwo
                diff = len1 - len2
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; diff; i++ </span><span class="cov8" title="1">{
                currentOne = currentOne.GetNext()
        }</span>

        <span class="cov8" title="1">for currentOne != nil &amp;&amp; currentTwo != nil </span><span class="cov8" title="1">{
                if currentOne == currentTwo </span><span class="cov8" title="1">{
                        return currentOne
                }</span>
                <span class="cov8" title="1">currentOne = currentOne.GetNext()
                currentTwo = currentTwo.GetNext()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i2ll *IntersectionOfTwoLinkedList) ExecuteByName(methodName string) <span class="cov8" title="1">{
        methods := map[string]func() *SingleLinkedList{
                "BruteForceMethod": i2ll.BruteForceMethod,
                "StackMethod":      i2ll.StackMethod,
                "TwoPointerMethod": i2ll.TwoPointerMethod,
        }

        result := methods[methodName]()
        if result != nil </span><span class="cov8" title="1">{
                i2ll.Result = result.GetData()
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package linkedlist

type IsLinkedListEven struct {
        Head   *SingleLinkedList
        Result bool
}

func NewIsLinkedListEven(head *SingleLinkedList) *IsLinkedListEven <span class="cov8" title="1">{
        return &amp;IsLinkedListEven{Head: head}
}</span>

func (ille *IsLinkedListEven) TwoPointerMethod() bool <span class="cov8" title="1">{
        slow := ille.Head
        fast := ille.Head

        for fast != nil &amp;&amp; fast.GetNext() != nil </span><span class="cov8" title="1">{
                fast = fast.GetNext().GetNext()
                slow = slow.GetNext()
        }</span>
        <span class="cov8" title="1">return fast == nil</span>
}

func (ille *IsLinkedListEven) Execute() <span class="cov8" title="1">{
        ille.Result = ille.TwoPointerMethod()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package linkedlist

type JosephusCircle struct {
        N      int
        M      int
        Result int
}

func NewJosephusCircle(N, M int) *JosephusCircle <span class="cov8" title="1">{
        return &amp;JosephusCircle{
                N: N,
                M: M,
        }
}</span>

func (jc *JosephusCircle) GetJosephusPosition() int <span class="cov8" title="1">{
        val := []int{}
        for i := 1; i &lt;= jc.N; i++ </span><span class="cov8" title="1">{
                val = append(val, i)
        }</span>
        <span class="cov8" title="1">head := ConvertArrayToCircularLinkedList(val)
        p := head
        for count := jc.N; count &gt; 1; count-- </span><span class="cov8" title="1">{
                for i := 0; i &lt; jc.M-1; i++ </span><span class="cov8" title="1">{
                        p = p.GetNext()
                }</span>
                <span class="cov8" title="1">p.SetNext(p.GetNext().GetNext())</span>
        }
        <span class="cov8" title="1">return p.GetData()</span>
}

func (jc *JosephusCircle) Execute() <span class="cov8" title="1">{
        jc.Result = jc.GetJosephusPosition()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package linkedlist

type MergeTwoSortedLinkedList struct {
        headOne    *SingleLinkedList
        headTwo    *SingleLinkedList
        mergedHead *SingleLinkedList
        Result     []int
}

func NewMergeTwoSortedLinkedList(headOne, headTwo *SingleLinkedList) *MergeTwoSortedLinkedList <span class="cov8" title="1">{
        return &amp;MergeTwoSortedLinkedList{
                headOne: headOne,
                headTwo: headTwo,
        }
}</span>

func (mtsll *MergeTwoSortedLinkedList) recursion(headOne, headTwo *SingleLinkedList) *SingleLinkedList <span class="cov8" title="1">{
        if headOne == nil </span><span class="cov8" title="1">{
                return headTwo
        }</span>
        <span class="cov8" title="1">if headTwo == nil </span><span class="cov8" title="1">{
                return headOne
        }</span>
        <span class="cov8" title="1">var head *SingleLinkedList
        if headOne.GetData() &lt; headTwo.GetData() </span><span class="cov8" title="1">{
                head = headOne
                head.SetNext(mtsll.recursion(headOne.GetNext(), headTwo))
        }</span> else<span class="cov8" title="1"> {
                head = headTwo
                head.SetNext(mtsll.recursion(headOne, headTwo.GetNext()))
        }</span>
        <span class="cov8" title="1">return head</span>
}

func (mtsll *MergeTwoSortedLinkedList) RecursionMethod() <span class="cov8" title="1">{
        mtsll.mergedHead = mtsll.recursion(mtsll.headOne, mtsll.headTwo)
}</span>

func (mtsll *MergeTwoSortedLinkedList) IterativeMethod() <span class="cov8" title="1">{
        head := &amp;SingleLinkedList{}
        current := head

        for mtsll.headOne != nil &amp;&amp; mtsll.headTwo != nil </span><span class="cov8" title="1">{
                if mtsll.headOne.GetData() &lt; mtsll.headTwo.GetData() </span><span class="cov8" title="1">{
                        current.SetNext(mtsll.headOne)
                        mtsll.headOne = mtsll.headOne.GetNext()
                }</span> else<span class="cov8" title="1"> {
                        current.SetNext(mtsll.headTwo)
                        mtsll.headTwo = mtsll.headTwo.GetNext()
                }</span>
                <span class="cov8" title="1">current = current.GetNext()</span>
        }

        <span class="cov8" title="1">if mtsll.headOne != nil </span><span class="cov8" title="1">{
                current.SetNext(mtsll.headOne)
        }</span> else<span class="cov8" title="1"> if mtsll.headTwo != nil </span><span class="cov8" title="1">{
                current.SetNext(mtsll.headTwo)
        }</span>
        <span class="cov8" title="1">mtsll.mergedHead = head.GetNext()</span>
}

func (mtsll *MergeTwoSortedLinkedList) ExecuteByMethodName(method string) <span class="cov8" title="1">{
        switch method </span>{
        case "RecursionMethod":<span class="cov8" title="1">
                mtsll.RecursionMethod()</span>
        case "IterativeMethod":<span class="cov8" title="1">
                mtsll.IterativeMethod()</span>
        }
        <span class="cov8" title="1">mtsll.Result = ConvertSingleLinkedListToArray(mtsll.mergedHead)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package linkedlist

type MiddleOfLinkedList struct {
        Head   *SingleLinkedList
        Result int
}

func NewMiddleOfLinkedList(head *SingleLinkedList) *MiddleOfLinkedList <span class="cov8" title="1">{
        return &amp;MiddleOfLinkedList{Head: head}
}</span>

func (mll *MiddleOfLinkedList) BruteForceMethod() int <span class="cov8" title="1">{
        len := GetSingleLinkedListLength(mll.Head)
        mid := len / 2
        current := mll.Head

        for current != nil </span><span class="cov8" title="1">{
                currentLength := GetSingleLinkedListLength(current)
                if currentLength == len-mid </span><span class="cov8" title="1">{
                        return current.GetData()
                }</span>
                <span class="cov8" title="1">current = current.GetNext()</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (mll *MiddleOfLinkedList) LengthMethod() int <span class="cov8" title="1">{
        len := GetSingleLinkedListLength(mll.Head)
        if len == 0 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">mid := len / 2
        current := mll.Head
        for i := 0; i &lt; mid; i++ </span><span class="cov8" title="1">{
                current = current.GetNext()
        }</span>
        <span class="cov8" title="1">return current.GetData()</span>
}

func (mll *MiddleOfLinkedList) TwoPointerMethod() int <span class="cov8" title="1">{
        slow := mll.Head
        fast := mll.Head
        for fast != nil &amp;&amp; fast.GetNext() != nil </span><span class="cov8" title="1">{
                fast = fast.GetNext().GetNext()
                slow = slow.GetNext()
        }</span>
        <span class="cov8" title="1">if slow == nil </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return slow.GetData()</span>
}

func (mll *MiddleOfLinkedList) HashMapMethod() int <span class="cov8" title="1">{
        count := 0
        nodeMap := make(map[int]*SingleLinkedList)
        current := mll.Head

        for current != nil </span><span class="cov8" title="1">{
                count++
                nodeMap[count] = current
                current = current.GetNext()
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">mid := count / 2
        return nodeMap[mid+1].GetData()</span>
}

func (mll *MiddleOfLinkedList) ExecuteByMethod(method string) <span class="cov8" title="1">{
        methods := map[string]func() int{
                "BruteForceMethod": mll.BruteForceMethod,
                "LengthMethod":     mll.LengthMethod,
                "TwoPointerMethod": mll.TwoPointerMethod,
                "HashMapMethod":    mll.HashMapMethod,
        }
        mll.Result = methods[method]()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Problem 2: Find nth node from the end of a Linked List.
*/
package linkedlist

type NthNodeFromEnd struct {
        Head   *SingleLinkedList
        Result int
        N      int
}

func NewNthNodeFromEnd(values []int, n int) *NthNodeFromEnd <span class="cov8" title="1">{
        nthNodeFromEnd := &amp;NthNodeFromEnd{}
        for _, value := range values </span><span class="cov8" title="1">{
                InsertAtEndofSingleLL(&amp;nthNodeFromEnd.Head, value)
        }</span>
        <span class="cov8" title="1">nthNodeFromEnd.N = n
        return nthNodeFromEnd</span>
}

func (nnfe *NthNodeFromEnd) Execute(methodName string) <span class="cov8" title="1">{
        methods := map[string]func() int{
                "BruteForceMethod": nnfe.BruteForceMethod,
                "HashMapMethod":    nnfe.HashMapMethod,
                "TwoPointerMethod": nnfe.TwoPointerMethod,
                "RecursionMethod":  nnfe.RecursionMethod,
        }
        nnfe.Result = methods[methodName]()
}</span>

func (nnfe *NthNodeFromEnd) BruteForceMethod() int <span class="cov8" title="1">{
        /*
                Time Complexity: O(n^2).
                For scanning the remaining list (from current node) for each node.
                Space Complexity: O(1).
        */
        current := nnfe.Head
        len := GetSingleLinkedListLength(current)
        if len &lt; nnfe.N </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">for current.GetNext() != nil &amp;&amp; len &gt; nnfe.N </span><span class="cov8" title="1">{
                current = current.GetNext()
                len = GetSingleLinkedListLength(current)
        }</span>
        <span class="cov8" title="1">if len == nnfe.N </span><span class="cov8" title="1">{
                return current.GetData()
        }</span>
        <span class="cov8" title="1">return -1</span>
}

func (nnfe *NthNodeFromEnd) HashMapMethod() int <span class="cov8" title="1">{
        /*
                M =&gt; Length of the linked list.
                Time Complexity: T(M) = O(M) Time for creating the hash table.
                Space Complexity: O(M) for hash table of size
        */
        len := GetSingleLinkedListLength(nnfe.Head)
        if len &lt; nnfe.N </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">hashMap := map[int]*SingleLinkedList{}
        current := nnfe.Head
        currentPosition := 1
        for current != nil </span><span class="cov8" title="1">{
                hashMap[currentPosition] = current
                current = current.GetNext()
                currentPosition++
        }</span>
        <span class="cov8" title="1">if val, ok := hashMap[len-nnfe.N+1]; ok </span><span class="cov8" title="1">{
                return val.GetData()
        }</span>
        <span class="cov8" title="1">return -1</span>
}

func (nnfe *NthNodeFromEnd) TwoPointerMethod() int <span class="cov8" title="1">{
        /*
                Time Complexity: O(n)
                Space Complexity: O(1)
        */

        if nnfe.N &lt; 0 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">var pTemp, pNthNode *SingleLinkedList
        pTemp = nnfe.Head
        for i := 1; i &lt; nnfe.N &amp;&amp; pTemp != nil; i++ </span><span class="cov8" title="1">{
                pTemp = pTemp.GetNext()
        }</span>
        <span class="cov8" title="1">if pTemp == nil </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">pNthNode = nnfe.Head
        for pTemp.GetNext() != nil </span><span class="cov8" title="1">{
                pTemp = pTemp.GetNext()
                pNthNode = pNthNode.GetNext()
        }</span>
        <span class="cov8" title="1">return pNthNode.GetData()</span>
}

func (nnfe *NthNodeFromEnd) RecursionMethod() int <span class="cov8" title="1">{
        /*
                Time Complexity: O(n) for pre recursive calls and O(n) for post recursive calls, which is =&gt; O(2n) = O(n).
                Space Complexity: O(n) for recursive stack.
        */
        counter := 0
        node := nnfe.recursionLogic(nnfe.Head, nnfe.N, &amp;counter)
        if node == nil </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return node.GetData()</span>
}

func (nnfe *NthNodeFromEnd) recursionLogic(head *SingleLinkedList, n int, counter *int) *SingleLinkedList <span class="cov8" title="1">{
        if head != nil </span><span class="cov8" title="1">{
                result := nnfe.recursionLogic(head.GetNext(), n, counter)
                (*counter)++
                if n == *counter </span><span class="cov8" title="1">{
                        return head
                }</span>
                <span class="cov8" title="1">return result</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/* Problem-39 How will you check if the linked list is palindrome or not?

Algorithm
1. Get the middle of the linked list.
2. Reverse the second half of the linked list.
3. Compare the first half and second half.
4. Construct the original linked list by reversing the second half again and attaching it back to the first half.

*/

package linkedlist

type PalindromeLinkedList struct {
        head   *SingleLinkedList
        Result bool
}

func NewPalindromeLinkedList(val []int) *PalindromeLinkedList <span class="cov8" title="1">{
        head := ConvertArrayToSingleLinkedList(val)
        return &amp;PalindromeLinkedList{
                head: head,
        }
}</span>

func (pll *PalindromeLinkedList) IsPalindrome() bool <span class="cov8" title="1">{
        if pll.head == nil || pll.head.GetNext() == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        // Step 1: Find the middle of the linkedlist
        <span class="cov8" title="1">slow, fast := pll.head, pll.head
        for fast != nil &amp;&amp; fast.GetNext() != nil </span><span class="cov8" title="1">{
                slow = slow.GetNext()
                fast = fast.GetNext().GetNext()
        }</span>

        // Step 2: Reverse the second half of the linkedlist
        <span class="cov8" title="1">var prev *SingleLinkedList
        current := slow
        for current != nil </span><span class="cov8" title="1">{
                next := current.GetNext()
                current.SetNext(prev)
                prev = current
                current = next
        }</span>

        // Step 3: Compare the first half and second half of the linkedlist
        <span class="cov8" title="1">firstHalf, secondHalf := pll.head, prev
        for secondHalf != nil </span><span class="cov8" title="1">{
                if firstHalf.GetData() != secondHalf.GetData() </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">firstHalf = firstHalf.GetNext()
                secondHalf = secondHalf.GetNext()</span>
        }

        // Step 4: Restore the original linkedlist
        // reverse the second half again and attach it to restore the original list

        <span class="cov8" title="1">var prevRestore *SingleLinkedList
        currentRestore := prev
        for currentRestore != nil </span><span class="cov8" title="1">{
                next := currentRestore.GetNext()
                currentRestore.SetNext(prevRestore)
                prevRestore = currentRestore
                currentRestore = next
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (pll *PalindromeLinkedList) Execute() <span class="cov8" title="1">{
        pll.Result = pll.IsPalindrome()
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Problem-59         Given a linked list and a value K,
                        partition it such that all nodes less than K come before nodes greater than or equal to K.
                           You should preserve the original relative order of the nodes in each of the two partitions.
                        For example,
                                Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and K = 3,
                                return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.
*/

package linkedlist

type PartitionByK struct {
        head   *SingleLinkedList
        K      int
        Result []int
}

func NewPartitionByK(val []int, K int) *PartitionByK <span class="cov8" title="1">{
        return &amp;PartitionByK{
                head: ConvertArrayToSingleLinkedList(val),
                K:    K,
        }
}</span>

func (obj *PartitionByK) partitionByK(head *SingleLinkedList, K int) *SingleLinkedList <span class="cov8" title="1">{
        if head == nil || head.GetNext() == nil </span><span class="cov8" title="1">{
                return head
        }</span>

        <span class="cov8" title="1">root := NewSingleLinkedList(0)
        pivot := NewSingleLinkedList(K)

        rootNext, pivotNext, current := root, pivot, head

        for current != nil </span><span class="cov8" title="1">{
                next := current.GetNext()
                if current.GetData() &gt;= K </span><span class="cov8" title="1">{
                        pivotNext.SetNext(current)
                        pivotNext = current
                        pivotNext.SetNext(nil)
                }</span> else<span class="cov8" title="1"> {
                        rootNext.SetNext(current)
                        rootNext = current
                }</span>
                <span class="cov8" title="1">current = next</span>
        }
        <span class="cov8" title="1">rootNext.SetNext(pivot.GetNext())
        return root.GetNext()</span>
}

func (obj *PartitionByK) Execute() <span class="cov8" title="1">{
        result := obj.partitionByK(obj.head, obj.K)
        obj.Result = ConvertSingleLinkedListToArray(result)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package linkedlist

type RemoveDuplicatesFromUnorderedList struct {
    head   *SingleLinkedList
    Result []int
}

func NewRemoveDuplicatesFromUnorderedList(val []int) *RemoveDuplicatesFromUnorderedList <span class="cov8" title="1">{
    return &amp;RemoveDuplicatesFromUnorderedList{
        head: ConvertArrayToSingleLinkedList(val),
    }
}</span>

func (obj *RemoveDuplicatesFromUnorderedList) RemoveDuplicates() <span class="cov8" title="1">{
    presentMap := make(map[int]bool)

    if obj.head == nil </span><span class="cov8" title="1">{
        return
    }</span>

    <span class="cov8" title="1">current := obj.head
    var prev *SingleLinkedList

    for current != nil </span><span class="cov8" title="1">{
        if _, ok := presentMap[current.GetData()]; ok </span><span class="cov8" title="1">{
            prev.SetNext(current.GetNext())
        }</span> else<span class="cov8" title="1"> {
            presentMap[current.GetData()] = true
            prev = current
        }</span>
        <span class="cov8" title="1">current = current.GetNext()</span>
    }
}

func (obj *RemoveDuplicatesFromUnorderedList) Execute() <span class="cov8" title="1">{
    obj.RemoveDuplicates()
    obj.Result = ConvertSingleLinkedListToArray(obj.head)
}</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Problem-54
        Given a singly linked list L : L1-&gt;L2-&gt;L3-&gt;L4-&gt;L5-&gt;....-&gt;Ln-1-&gt;Ln
        Convert it to L1-&gt;Ln-&gt;L2-&gt;Ln-2......
*/

package linkedlist

type ReorderLinkedList struct {
        head   *SingleLinkedList
        Result []int
}

func NewReorderLinkedList(val []int) *ReorderLinkedList <span class="cov8" title="1">{
        return &amp;ReorderLinkedList{
                head: ConvertArrayToSingleLinkedList(val),
        }
}</span>

func (obj *ReorderLinkedList) ReorderLinkedList() <span class="cov8" title="1">{
        if obj.head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">slowPointer := obj.head
        fastPointer := obj.head.GetNext()

        for fastPointer != nil &amp;&amp; fastPointer.GetNext() != nil </span><span class="cov8" title="1">{
                fastPointer = fastPointer.GetNext().GetNext()
                slowPointer = slowPointer.GetNext()
        }</span>

        <span class="cov8" title="1">head2 := slowPointer.GetNext()
        slowPointer.SetNext(nil)

        // reverse second half

        head2 = obj.reverse(head2)
        obj.alternate(obj.head, head2)</span>
}

func (obj *ReorderLinkedList) reverse(head *SingleLinkedList) *SingleLinkedList <span class="cov8" title="1">{
        if head == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">reversedList := head
        pointer := head.GetNext()

        reversedList.SetNext(nil)

        for pointer != nil </span><span class="cov8" title="1">{
                temp := pointer
                pointer = pointer.GetNext()
                temp.SetNext(reversedList)
                reversedList = temp
        }</span>
        <span class="cov8" title="1">return reversedList</span>
}

func (obj *ReorderLinkedList) alternate(head1, head2 *SingleLinkedList) <span class="cov8" title="1">{
        pointer := head1
        head1 = head1.GetNext()

        nextList := false

        for head1 != nil &amp;&amp; head2 != nil </span><span class="cov8" title="1">{
                if (head2 != nil &amp;&amp; !nextList) || head1 == nil </span><span class="cov8" title="1">{
                        pointer.SetNext(head2)
                        head2 = head2.GetNext()
                        nextList = true
                        pointer = pointer.GetNext()
                }</span> else<span class="cov8" title="1"> {
                        pointer.SetNext(head1)
                        head1 = head1.GetNext()
                        nextList = false
                        pointer = pointer.GetNext()
                }</span>
        }
        <span class="cov8" title="1">if head1 != nil </span><span class="cov8" title="1">{
                pointer.SetNext(head1)
        }</span> else<span class="cov8" title="1"> if head2 != nil </span><span class="cov8" title="1">{
                pointer.SetNext(head2)
        }</span>
}

func (obj *ReorderLinkedList) Execute() <span class="cov8" title="1">{
        obj.ReorderLinkedList()
        obj.Result = ConvertSingleLinkedListToArray(obj.head)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package linkedlist

type ReverseLinkedListInPairs struct {
        Head        *SingleLinkedList
        ReverseHead *SingleLinkedList
        Result      []int
}

func NewReverseLinkedListInPairs(values []int) *ReverseLinkedListInPairs <span class="cov8" title="1">{
        head := ConvertArrayToSingleLinkedList(values)
        return &amp;ReverseLinkedListInPairs{
                Head: head,
        }
}</span>

func (rllip *ReverseLinkedListInPairs) RecursiveMethod() <span class="cov8" title="1">{
        rllip.ReverseHead = rllip.recursion(rllip.Head)
}</span>

func (rllp *ReverseLinkedListInPairs) recursion(head *SingleLinkedList) *SingleLinkedList <span class="cov8" title="1">{
        var temp *SingleLinkedList
        if head == nil || head.GetNext() == nil </span><span class="cov8" title="1">{
                return head
        }</span>
        <span class="cov8" title="1">temp = head.GetNext()
        head.SetNext(temp.GetNext())
        temp.SetNext(head)
        head = temp

        head.GetNext().SetNext(rllp.recursion(head.GetNext().GetNext()))
        return head</span>
}

func (rllip *ReverseLinkedListInPairs) IterativeMethod() <span class="cov8" title="1">{
        var tempOne, tempTwo *SingleLinkedList
        head := rllip.Head
        for head != nil &amp;&amp; head.GetNext() != nil </span><span class="cov8" title="1">{
                if tempOne != nil </span><span class="cov8" title="1">{
                        tempOne.GetNext().SetNext(head.GetNext())
                }</span>
                <span class="cov8" title="1">tempOne = head.GetNext()
                head.SetNext(head.GetNext().GetNext())
                tempOne.SetNext(head)
                if tempTwo == nil </span><span class="cov8" title="1">{
                        tempTwo = tempOne
                }</span>
                <span class="cov8" title="1">head = head.GetNext()</span>
        }
        <span class="cov8" title="1">rllip.ReverseHead = tempTwo</span>
}

func (rllip *ReverseLinkedListInPairs) ExecuteByMethodName(methodName string) <span class="cov8" title="1">{
        switch methodName </span>{
        case "RecursiveMethod":<span class="cov8" title="1">
                rllip.RecursiveMethod()</span>
        case "IterativeMethod":<span class="cov8" title="1">
                rllip.IterativeMethod()</span>
        }
        <span class="cov8" title="1">rllip.Result = ConvertSingleLinkedListToArray(rllip.ReverseHead)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package linkedlist

type ReverseSingleLinkedList struct {
        Head   *SingleLinkedList
        Result []int
}

func NewReverseSingleLinkedList(values []int) *ReverseSingleLinkedList <span class="cov8" title="1">{
        reverseSingleLinkedList := ReverseSingleLinkedList{}
        for _, value := range values </span><span class="cov8" title="1">{
                InsertAtEndofSingleLL(&amp;reverseSingleLinkedList.Head, value)
        }</span>
        <span class="cov8" title="1">return &amp;reverseSingleLinkedList</span>
}

/*
        Time Complexity: O(n), for scanning the list of size n
        Space Complexity: O(1), for creating a temporary variable.
*/

func (rsll *ReverseSingleLinkedList) IterativeApproach() <span class="cov8" title="1">{
        current := rsll.Head
        var prev *SingleLinkedList

        for current != nil </span><span class="cov8" title="1">{
                next := current.GetNext()
                current.SetNext(prev)
                prev = current
                current = next
        }</span>

        <span class="cov8" title="1">rsll.Head = prev</span>
}

/*
        Time Complexity: O(n), for scanning the list of size n
        Space Complexity: O(n), for storing the list in the recursive stack.
*/

func (rsll *ReverseSingleLinkedList) RecursiveApproach() <span class="cov8" title="1">{
        rsll.Head = rsll.reverseRecursively(rsll.Head)
}</span>

func (rsll *ReverseSingleLinkedList) reverseRecursively(head *SingleLinkedList) *SingleLinkedList <span class="cov8" title="1">{
        if head == nil || head.GetNext() == nil </span><span class="cov8" title="1">{
                return head
        }</span>
        <span class="cov8" title="1">newHead := rsll.reverseRecursively(head.GetNext())
        head.GetNext().SetNext(head)
        head.SetNext(nil)
        return newHead</span>
}

func (rsll *ReverseSingleLinkedList) ExecuteByName(methodName string) <span class="cov8" title="1">{
        reverse := map[string]func(){
                "IterativeApproach": rsll.IterativeApproach,
                "RecursiveApproach": rsll.RecursiveApproach,
        }
        reverse[methodName]()
        current := rsll.Head
        rsll.Result = []int{}
        for current != nil </span><span class="cov8" title="1">{
                rsll.Result = append(rsll.Result, current.GetData())
                current = current.GetNext()
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
        Problem-57
                Given a list, rotate the list to the right by k places, where k is non-negative.
                Example: 1-&gt;-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
                Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
*/

package linkedlist

type RotateByK struct {
        head   *SingleLinkedList
        k      int
        Result []int
}

func NewRotateByK(val []int, k int) *RotateByK <span class="cov8" title="1">{
        return &amp;RotateByK{
                k:    k,
                head: ConvertArrayToSingleLinkedList(val),
        }
}</span>

func (obj *RotateByK) rotateByK() *SingleLinkedList <span class="cov8" title="1">{
        if obj.head == nil || obj.head.GetNext() == nil </span><span class="cov8" title="1">{
                return obj.head
        }</span>

        <span class="cov8" title="1">n := obj.k
        rotateStart, rotateEnd := obj.head, obj.head

        for n &gt; 0 </span><span class="cov8" title="1">{
                n--
                rotateEnd = rotateEnd.GetNext()
                if rotateEnd == nil </span><span class="cov8" title="1">{
                        rotateEnd = obj.head
                }</span>
        }

        <span class="cov8" title="1">if rotateStart == rotateEnd </span><span class="cov8" title="1">{
                return obj.head
        }</span>

        <span class="cov8" title="1">for rotateEnd.GetNext() != nil </span><span class="cov8" title="1">{
                rotateStart = rotateStart.GetNext()
                rotateEnd = rotateEnd.GetNext()
        }</span>

        <span class="cov8" title="1">temp := rotateStart.GetNext()
        rotateEnd.SetNext(obj.head)
        rotateStart.SetNext(nil)
        return temp</span>
}

func (obj *RotateByK) Execute() <span class="cov8" title="1">{
        result := obj.rotateByK()
        obj.Result = ConvertSingleLinkedListToArray(result)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package linkedlist

type SingleLinkedList struct {
        CustomData interface{}
        data       int
        nextNode   *SingleLinkedList
}

func NewSingleLinkedList(data int) *SingleLinkedList <span class="cov8" title="1">{
        return &amp;SingleLinkedList{
                data: data,
        }
}</span>

func (sll *SingleLinkedList) SetData(data int) <span class="cov8" title="1">{
        sll.data = data
}</span>

func (sll *SingleLinkedList) GetData() int <span class="cov8" title="1">{
        return sll.data
}</span>

func (sll *SingleLinkedList) SetNext(nextNode *SingleLinkedList) <span class="cov8" title="1">{
        sll.nextNode = nextNode
}</span>

func (sll *SingleLinkedList) GetNext() *SingleLinkedList <span class="cov8" title="1">{
        return sll.nextNode
}</span>

/*
        Time Complexity: O(n), for scanning the list of size n Space Complexity: O(1), for creating a temporary variable.
*/

func GetSingleLinkedListLength(head *SingleLinkedList) int <span class="cov8" title="1">{
        var length int
        currentNode := head
        for currentNode != nil </span><span class="cov8" title="1">{
                length++
                currentNode = currentNode.GetNext()
        }</span>
        <span class="cov8" title="1">return length</span>
}

func SearchInSingleLL(head *SingleLinkedList, data int) *SingleLinkedList <span class="cov8" title="1">{
        currentNode := head
        for currentNode != nil </span><span class="cov8" title="1">{
                if currentNode.GetData() == data </span><span class="cov8" title="1">{
                        return currentNode
                }</span>
                <span class="cov8" title="1">currentNode = currentNode.GetNext()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func InsertAtStartofSingleLL(head **SingleLinkedList, data int) <span class="cov8" title="1">{
        newNode := NewSingleLinkedList(data)
        newNode.SetNext(*head)
        *head = newNode
}</span>

func InsertAtEndofSingleLL(head **SingleLinkedList, data int) <span class="cov8" title="1">{
        newNode := NewSingleLinkedList(data)
        if *head == nil </span><span class="cov8" title="1">{
                *head = newNode
                return
        }</span>
        <span class="cov8" title="1">currentNode := *head
        for currentNode.GetNext() != nil </span><span class="cov8" title="1">{
                currentNode = currentNode.GetNext()
        }</span>
        <span class="cov8" title="1">currentNode.SetNext(newNode)</span>
}

func InsertAtPositionOfSingleLL(head **SingleLinkedList, data, position int) <span class="cov8" title="1">{
        if position == 0 </span><span class="cov8" title="1">{
                InsertAtStartofSingleLL(head, data)
                return
        }</span>

        <span class="cov8" title="1">newNode := NewSingleLinkedList(data)

        currentNode := *head
        for i := 0; i &lt; position-1 &amp;&amp; currentNode != nil; i++ </span><span class="cov8" title="1">{
                currentNode = currentNode.GetNext()
        }</span>

        <span class="cov8" title="1">if currentNode == nil </span><span class="cov8" title="1">{
                return // out of range
        }</span>
        <span class="cov8" title="1">newNode.SetNext(currentNode.GetNext())
        currentNode.SetNext(newNode)</span>
}

func DeleteAtStartOfSingleLL(head **SingleLinkedList) <span class="cov8" title="1">{
        if *head != nil </span><span class="cov8" title="1">{
                *head = (*head).GetNext()
        }</span>
}

func DeleteAtEndSingleLL(head **SingleLinkedList) <span class="cov8" title="1">{
        if *head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if (*head).GetNext() == nil </span><span class="cov8" title="1">{
                *head = nil
                return
        }</span>
        <span class="cov8" title="1">currentNode := *head
        for currentNode.GetNext().GetNext() != nil </span><span class="cov8" title="1">{
                currentNode = currentNode.GetNext()
        }</span>
        <span class="cov8" title="1">currentNode.SetNext(nil)</span>
}

func DeleteAtPositionOfSingleLL(head **SingleLinkedList, position int) <span class="cov8" title="1">{
        if position == 0 </span><span class="cov8" title="1">{
                DeleteAtStartOfSingleLL(head)
                return
        }</span>
        <span class="cov8" title="1">currentNode := *head
        for i := 0; i &lt; position-1 &amp;&amp; currentNode != nil; i++ </span><span class="cov8" title="1">{
                currentNode = currentNode.GetNext()
        }</span>
        <span class="cov8" title="1">if currentNode == nil || currentNode.GetNext() == nil </span><span class="cov8" title="1">{
                return // position is out of bounds
        }</span>
        <span class="cov8" title="1">currentNode.SetNext(currentNode.GetNext().GetNext())</span>
}

func ConvertArrayToSingleLinkedList(val []int) *SingleLinkedList <span class="cov8" title="1">{
        if len(val) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var head *SingleLinkedList
        for i := len(val) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                InsertAtStartofSingleLL(&amp;head, val[i])
        }</span>
        <span class="cov8" title="1">return head</span>
}

func ConvertSingleLinkedListToArray(head *SingleLinkedList) []int <span class="cov8" title="1">{
        result := []int{}
        currentNode := head
        for currentNode != nil </span><span class="cov8" title="1">{
                result = append(result, currentNode.GetData())
                currentNode = currentNode.GetNext()
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package linkedlist

type SplitCircularLinkedList struct {
        head      *CircularLinkedList
        ResultOne []int
        ResultTwo []int
}

func NewSplitCircularLinkedList(values []int) *SplitCircularLinkedList <span class="cov8" title="1">{
        head := ConvertArrayToCircularLinkedList(values)
        return &amp;SplitCircularLinkedList{head, []int{}, []int{}}
}</span>

func (scll *SplitCircularLinkedList) SplitList(head *CircularLinkedList, resultOne, resultTwo **CircularLinkedList) <span class="cov8" title="1">{
        slowPtr, fastPtr := head, head
        if head == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for fastPtr.GetNext() != head &amp;&amp; fastPtr.GetNext().GetNext() != head </span><span class="cov8" title="1">{
                fastPtr = fastPtr.GetNext().GetNext()
                slowPtr = slowPtr.GetNext()
        }</span>

        <span class="cov8" title="1">if fastPtr.GetNext().GetNext() == head </span><span class="cov8" title="1">{
                fastPtr = fastPtr.GetNext()
        }</span>

        <span class="cov8" title="1">*resultOne = head
        if head.GetNext() != head </span><span class="cov8" title="1">{
                *resultTwo = slowPtr.GetNext()
        }</span>

        <span class="cov8" title="1">fastPtr.SetNext(slowPtr.GetNext())
        slowPtr.SetNext(head)</span>
}

func (scll *SplitCircularLinkedList) Execute() <span class="cov8" title="1">{
        var resultOne, resultTwo *CircularLinkedList
        scll.SplitList(scll.head, &amp;resultOne, &amp;resultTwo)
        scll.ResultOne = ConvertCircularLinkedListToArray(resultOne)
        scll.ResultTwo = ConvertCircularLinkedListToArray(resultTwo)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package linkedlist

import "errors"

const MIN_NODE_CAPACITY = 4

type UnrolledLinkedList struct {
        NodeCapacity int
        CurrentSize  int
        FirstNode    *ULLNode
        LastNode     *ULLNode
}

type ULLNode struct {
        Data         []int
        NextNode     *ULLNode
        PreviousNode *ULLNode
        Size         int
}

func NewUnrolledLinkedList(nodeCapacity int) (ull *UnrolledLinkedList, err error) <span class="cov8" title="1">{
        if nodeCapacity &lt; MIN_NODE_CAPACITY </span><span class="cov8" title="1">{
                err = errors.New("node capacity should be greater than min node capacity")
                return
        }</span>
        <span class="cov8" title="1">ull = &amp;UnrolledLinkedList{
                NodeCapacity: nodeCapacity,
        }

        firstNode := &amp;ULLNode{
                Data: make([]int, nodeCapacity),
        }
        ull.FirstNode = firstNode
        ull.LastNode = firstNode
        return</span>
}

func (list *UnrolledLinkedList) Size() int <span class="cov8" title="1">{
        return list.CurrentSize
}</span>

func (list *UnrolledLinkedList) IsEmpty() bool <span class="cov8" title="1">{
        return list.CurrentSize == 0
}</span>

func (list *UnrolledLinkedList) Contains(o int) bool <span class="cov8" title="1">{
        return list.Search(o) != -1
}</span>

func (list *UnrolledLinkedList) Add(val int) bool <span class="cov8" title="1">{
        list.insertIntoNode(list.LastNode, list.LastNode.Size, val)
        return true
}</span>

func (list *UnrolledLinkedList) Remove(val int) bool <span class="cov8" title="1">{
        node := list.FirstNode
        for node != nil </span><span class="cov8" title="1">{
                for i := 0; i &lt; node.Size; i++ </span><span class="cov8" title="1">{
                        if node.Data[i] == val </span><span class="cov8" title="1">{
                                list.removeFromNode(node, i)
                                return true
                        }</span>
                }
                <span class="cov8" title="1">node = node.NextNode</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (list *UnrolledLinkedList) Clear() <span class="cov8" title="1">{
        node := list.FirstNode.NextNode
        for node != nil </span><span class="cov8" title="1">{
                next := node.NextNode
                node.NextNode = nil
                node.PreviousNode = nil
                node.Data = nil
                node = next
        }</span>
        <span class="cov8" title="1">list.LastNode = list.FirstNode
        list.FirstNode.Data = make([]int, list.NodeCapacity)
        list.FirstNode.Size = 0
        list.FirstNode.NextNode = nil
        list.CurrentSize = 0</span>
}

func (list *UnrolledLinkedList) Get(index int) (int, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= list.CurrentSize </span><span class="cov8" title="1">{
                return 0, errors.New("index out of bounds")
        }</span>
        <span class="cov8" title="1">node, p := list.findNode(index)
        return node.Data[index-p], nil</span>
}

func (list *UnrolledLinkedList) Set(index int, element int) (int, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= list.CurrentSize </span><span class="cov8" title="1">{
                return 0, errors.New("index out of bounds")
        }</span>
        <span class="cov8" title="1">node, p := list.findNode(index)
        oldElement := node.Data[index-p]
        node.Data[index-p] = element
        return oldElement, nil</span>
}

func (list *UnrolledLinkedList) AddAt(index int, element int) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; list.CurrentSize </span><span class="cov8" title="1">{
                return errors.New("index out of bounds")
        }</span>
        <span class="cov8" title="1">node, p := list.findNode(index)
        list.insertIntoNode(node, index-p, element)
        return nil</span>
}

func (list *UnrolledLinkedList) RemoveAt(index int) (int, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= list.CurrentSize </span><span class="cov8" title="1">{
                return 0, errors.New("index out of bounds")
        }</span>
        <span class="cov8" title="1">node, p := list.findNode(index)
        element := node.Data[index-p]
        list.removeFromNode(node, index-p)
        return element, nil</span>
}

func (list *UnrolledLinkedList) findNode(index int) (*ULLNode, int) <span class="cov8" title="1">{
        node := list.FirstNode
        p := 0
        if list.CurrentSize-index &gt; index </span><span class="cov8" title="1">{
                for p &lt;= index-node.Size </span><span class="cov8" title="1">{
                        p += node.Size
                        node = node.NextNode
                }</span>
        } else<span class="cov8" title="1"> {
                node = list.LastNode
                p = list.CurrentSize
                for p -= node.Size; p &gt; index; </span><span class="cov0" title="0">{
                        node = node.PreviousNode
                }</span>
        }
        <span class="cov8" title="1">return node, p</span>
}

func (list *UnrolledLinkedList) insertIntoNode(node *ULLNode, ptr int, element int) <span class="cov8" title="1">{
        if node.Size == list.NodeCapacity </span><span class="cov8" title="1">{
                newNode := &amp;ULLNode{
                        Data: make([]int, list.NodeCapacity),
                }
                elementsToMove := list.NodeCapacity / 2
                startIndex := list.NodeCapacity - elementsToMove
                copy(newNode.Data, node.Data[startIndex:])
                for i := startIndex; i &lt; list.NodeCapacity; i++ </span><span class="cov8" title="1">{
                        node.Data[i] = 0
                }</span>
                <span class="cov8" title="1">node.Size -= elementsToMove
                newNode.Size = elementsToMove
                newNode.NextNode = node.NextNode
                newNode.PreviousNode = node
                if node.NextNode != nil </span><span class="cov0" title="0">{
                        node.NextNode.PreviousNode = newNode
                }</span>
                <span class="cov8" title="1">node.NextNode = newNode
                if node == list.LastNode </span><span class="cov8" title="1">{
                        list.LastNode = newNode
                }</span>
                <span class="cov8" title="1">if ptr &gt; node.Size </span><span class="cov8" title="1">{
                        node = newNode
                        ptr -= node.Size
                }</span>
        }
        <span class="cov8" title="1">copy(node.Data[ptr+1:], node.Data[ptr:node.Size])
        node.Data[ptr] = element
        node.Size++
        list.CurrentSize++</span>
}

func (list *UnrolledLinkedList) removeFromNode(node *ULLNode, ptr int) <span class="cov8" title="1">{
        copy(node.Data[ptr:], node.Data[ptr+1:node.Size])
        node.Data[node.Size-1] = 0
        node.Size--
        if node.NextNode != nil &amp;&amp; node.NextNode.Size+node.Size &lt;= list.NodeCapacity </span><span class="cov8" title="1">{
                list.mergeWithNextNode(node)
        }</span> else<span class="cov8" title="1"> if node.PreviousNode != nil &amp;&amp; node.PreviousNode.Size+node.Size &lt;= list.NodeCapacity </span><span class="cov0" title="0">{
                list.mergeWithNextNode(node.PreviousNode)
        }</span>
        <span class="cov8" title="1">list.CurrentSize--</span>
}

func (list *UnrolledLinkedList) mergeWithNextNode(node *ULLNode) <span class="cov8" title="1">{
        next := node.NextNode
        copy(node.Data[node.Size:], next.Data[:next.Size])
        node.Size += next.Size
        if next.NextNode != nil </span><span class="cov8" title="1">{
                next.NextNode.PreviousNode = node
        }</span>
        <span class="cov8" title="1">node.NextNode = next.NextNode
        if next == list.LastNode </span><span class="cov0" title="0">{
                list.LastNode = node
        }</span>
}

func (list *UnrolledLinkedList) Search(o int) int <span class="cov8" title="1">{
        node := list.FirstNode
        index := 0
        for node != nil </span><span class="cov8" title="1">{
                for i := 0; i &lt; node.Size; i++ </span><span class="cov8" title="1">{
                        if node.Data[i] == o </span><span class="cov8" title="1">{
                                return index + i
                        }</span>
                }
                <span class="cov8" title="1">index += node.Size
                node = node.NextNode</span>
        }
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
        Problem-2: Given an array, check whether the array is in sorted order with recursion.

        Time Complexity: O(n). Space Complexity: O(݊n) for recursive stack space
*/

package recursion

type SortedArray struct {
        Array  []int
        Result bool
}

func (soa *SortedArray) Recursion(index int) bool <span class="cov8" title="1">{
        if len(soa.Array) == 1 || index == 1 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if soa.Array[index-1] &lt; soa.Array[index-2] </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return soa.Recursion(index - 1)</span>
}

func NewSortedArray(array []int) *SortedArray <span class="cov8" title="1">{
        return &amp;SortedArray{
                Array: array,
        }
}</span>

func (soa *SortedArray) Execute() <span class="cov8" title="1">{
        soa.Result = soa.Recursion(len(soa.Array))
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Problem-1 Discuss Towers of Hanoi puzzle.
  - Only one disk can be moved at a time.
  - Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack.
  - No disk may be placed on top of a smaller disk.

It comprises three main recursive steps:
 1. Shift disks from the source rod to an auxiliary rod.
 2. Move the remaining disk to the target rod.
 3. Shift the disks from the auxiliary rod to the target rod.
*/
package recursion

import (
        "fmt"
)

type TowerOfHanoi struct {
        MoveCount     int
        NumberOfDisks int
        Move          []string
}

func (toh *TowerOfHanoi) Recursion(current int, from, to, aux string) <span class="cov8" title="1">{
        if current == 1 </span><span class="cov8" title="1">{
                toh.MoveCount++
                toh.Move = append(toh.Move, fmt.Sprintf("%v -&gt; %v", from, to)) // Only 1 disk move directly
                return
        }</span>

        <span class="cov8" title="1">toh.Recursion(current-1, from, aux, to)
        toh.MoveCount++
        toh.Move = append(toh.Move, fmt.Sprintf("%v -&gt; %v", from, to))
        toh.Recursion(current-1, aux, to, from)</span>
}

func NewTowerOfHanoi(numberOfDisks int) *TowerOfHanoi <span class="cov8" title="1">{
        return &amp;TowerOfHanoi{
                NumberOfDisks: numberOfDisks,
                Move:          []string{},
        }
}</span>

func (toh *TowerOfHanoi) Execute() <span class="cov8" title="1">{
        toh.Recursion(toh.NumberOfDisks, "A", "C", "B")
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
        Problem-21
        Given a string containing D D′D and D D′D where D indicates a push operation and D indicates
        a pop operation, and with the stack initially empty, formulate a rule to check whether a given
        string D of operations is admissible or not?
*/

package stack

type AdmissibleString struct {
        stack  *LinkedListStack
        input  string
        Result bool
}

func NewAdmissibleString(input string) *AdmissibleString <span class="cov8" title="1">{
        return &amp;AdmissibleString{
                stack: NewLinkedListStack(),
                input: input,
        }
}</span>

func (s *AdmissibleString) IsAdmissible() bool <span class="cov8" title="1">{
        for _, char := range s.input </span><span class="cov8" title="1">{
                if char == 'S' </span><span class="cov8" title="1">{
                        s.stack.Push(char)
                }</span> else<span class="cov8" title="1"> {
                        _, err := s.stack.Pop()
                        if err != nil </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func (s *AdmissibleString) Execute() <span class="cov8" title="1">{
        s.Result = s.IsAdmissible()
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
Problem-1 Discuss how stacks can be used for checking balancing of symbols/parentheses.

Solution: Stacks can be used to check whether the given expression has balanced symbols. This algorithm is very useful in compilers. Each
time the parser reads one character at a time. If the character is an opening delimiter such as (, {, or [- then it is written to the stack. When a
closing delimiter is encountered like ), }, or ]- the stack is popped.

The opening and closing delimiters are then compared. If they match, the parsing of the string continues. If they do not match, the parser
indicates that there is an error on the line.

A linear-time O(n) algorithm based on stack can be given as:
        a) Create a stack.
        b) while (end of input is not reached) {
                1) If the character read is not a symbol to be balanced, ignore it.
                2) If the character is an opening symbol like (, [, {, push it onto the stack
                3) If it is a closing symbol like ),],}, then if the stack is empty report an error. Otherwise pop the stack.
                4) If the symbol popped is not the corresponding opening symbol, report an error.
        }
        c) At end of input, if the stack is not empty report an error

*/

package stack

type BalanceParanthesis struct {
        stack  *LinkedListStack
        Input  string
        Result bool
}

func NewBalanceParanthesis(input string) *BalanceParanthesis <span class="cov8" title="1">{
        return &amp;BalanceParanthesis{
                stack: NewLinkedListStack(),
                Input: input,
        }
}</span>

func (bp *BalanceParanthesis) IsBalanced() bool <span class="cov8" title="1">{

        pairs := map[rune]rune{
                ')': '(',
                '}': '{',
                ']': '[',
        }

        if len(bp.Input) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, c := range bp.Input </span><span class="cov8" title="1">{
                if c == '(' || c == '{' || c == '[' </span><span class="cov8" title="1">{
                        bp.stack.Push(c)
                }</span> else<span class="cov8" title="1"> if c == ')' || c == '}' || c == ']' </span><span class="cov8" title="1">{
                        pair, err := bp.stack.Peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">if pair.(rune) != pairs[c] </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">bp.stack.Pop()</span>
                }
        }

        <span class="cov8" title="1">return bp.stack.IsEmpty()</span>
}

func (bp *BalanceParanthesis) Execute() <span class="cov8" title="1">{
        bp.Result = bp.IsBalanced()
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package stack

import (
        "fmt"
        "math"
)

const (
        DefaultDynamicCapacity = 16
        MaxDynamicCapacity     = 1 &lt;&lt; 15
)

type DynamicArrayStack struct {
        stack    []int
        top      int
        capacity int
}

func NewDynamicArrayStack() *DynamicArrayStack <span class="cov8" title="1">{
        return &amp;DynamicArrayStack{
                stack:    make([]int, DefaultDynamicCapacity),
                top:      -1,
                capacity: DefaultDynamicCapacity,
        }
}</span>

func NewDynamicArrayStackWithCapacity(cap int) *DynamicArrayStack <span class="cov8" title="1">{
        return &amp;DynamicArrayStack{
                stack:    make([]int, cap),
                top:      -1,
                capacity: cap,
        }
}</span>

func (s *DynamicArrayStack) IsEmpty() bool <span class="cov8" title="1">{
        return s.top &lt; 0
}</span>

func (s *DynamicArrayStack) Size() int <span class="cov8" title="1">{
        return s.top + 1
}</span>

func (s *DynamicArrayStack) Push(value int) <span class="cov8" title="1">{
        if s.Size() == s.capacity </span><span class="cov8" title="1">{
                s.expand()
        }</span>
        <span class="cov8" title="1">s.top++
        s.stack[s.top] = value</span>
}

func (s *DynamicArrayStack) Pop() (int, error) <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return 0, ErrStackEmpty
        }</span>
        <span class="cov8" title="1">value := s.stack[s.top]
        s.stack[s.top] = math.MinInt
        s.top--
        if s.Size() &lt;= s.capacity/4 </span><span class="cov8" title="1">{
                s.shrink()
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

func (s *DynamicArrayStack) Top() (int, error) <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return 0, ErrStackEmpty
        }</span>
        <span class="cov8" title="1">return s.stack[s.top], nil</span>
}

func (s *DynamicArrayStack) Clear() <span class="cov8" title="1">{
        for i := 0; i &lt; s.top; i++ </span><span class="cov8" title="1">{
                s.stack[i] = math.MinInt
        }</span>
        <span class="cov8" title="1">s.top = -1</span>
}

func (s *DynamicArrayStack) ToString() string <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return "[]"
        }</span>
        <span class="cov8" title="1">str := fmt.Sprintf("%+v", s.stack[0])
        for i := 1; i &lt;= s.top; i++ </span><span class="cov8" title="1">{
                str = fmt.Sprintf("%+v , %+v", str, s.stack[i])
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[%+v]", str)</span>
}

func (s *DynamicArrayStack) expand() <span class="cov8" title="1">{
        newCapacity := s.capacity &lt;&lt; 1
        if newCapacity &gt; MaxDynamicCapacity </span><span class="cov8" title="1">{
                newCapacity = MaxDynamicCapacity
        }</span>

        <span class="cov8" title="1">newStack := make([]int, newCapacity)
        copy(newStack, s.stack)
        s.stack = newStack
        s.capacity = newCapacity</span>
}

func (s *DynamicArrayStack) shrink() <span class="cov8" title="1">{
        newCapacity := s.capacity &gt;&gt; 1
        if newCapacity &lt; DefaultDynamicCapacity </span><span class="cov8" title="1">{
                newCapacity = DefaultDynamicCapacity
        }</span>
        <span class="cov8" title="1">newStack := make([]int, newCapacity)
        copy(newStack, s.stack)
        s.stack = newStack
        s.capacity = newCapacity</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
        Problem 22
        The problem is about finding the "span" for each element in an array ( A ). Let's break down the problem into parts to understand it more clearly.

        ### Problem Explanation
                1. **Span ( S[i] ) Definition**:
                - For each element ( A[i] ) in the array ( A ), the span ( S[i] ) is defined as the **maximum number of consecutive elements** that immediately precede ( A[i] ) and satisfy the condition ( A[j] leq A[j+1] ).
                - In other words, it’s the length of the longest subarray ending at ( A[i] ) where each element is less than or equal to the next one.

                2. **Alternative Explanation**:
                - Another way to look at the problem is as follows: given an array ( A ), find the maximum difference ( j - i ) such that ( A[i] &lt; A[j] ).
                - This means we're looking for two indices ( i ) and ( j ) (where ( j &gt; i )) such that the element at index ( i ) is less than the element at index ( j ), and the difference between ( j ) and ( i ) (i.e., how far apart these indices are) is maximized.

        ### Example to Clarify

                Let’s say we have an array:
                        A = [6, 3, 4, 5, 2, 6, 4]

                For each element ( A[i] ), we want to find the span ( S[i] ).

                - For ( A[0] = 6 ): No previous elements, so ( S[0] = 1 ).
                - For ( A[1] = 3 ): No consecutive increasing elements before it, so ( S[1] = 1 ).
                - For ( A[2] = 4 ): ( A[1] leq A[2] ), so ( S[2] = 2 ).
                - For ( A[3] = 5 ): ( A[1] leq A[2] leq A[3] ), so ( S[3] = 3 ).
                - For ( A[4] = 2 ): No consecutive increasing elements before it, so ( S[4] = 1 ).
                - For ( A[5] = 6 ): ( A[4] leq A[5] ), so ( S[5] = 2 ).
                - For ( A[6] = 4 ): ( A[5] leq A[6] ), so ( S[6] = 2 ).

                So, the spans ( S ) for each element are:
                        S = [1, 1, 2, 3, 1, 2, 2]

        ### Goal of the Problem
                The main objective here is to compute this span ( S[i] ) for each element in the array efficiently,
                ideally in a way that doesn't involve examining every previous element for each ( i ) (which would be slow for large arrays). There may be an efficient approach involving stacks or specific algorithms that can help calculate these spans in linear time.
*/

package stack

type FindingOfSpans struct {
        stack  *LinkedListStack
        input  []int
        Result []int
}

func NewFindingOfSpans(input []int) *FindingOfSpans <span class="cov8" title="1">{
        return &amp;FindingOfSpans{
                stack: NewLinkedListStack(),
                input: input,
        }
}</span>

func (f *FindingOfSpans) findingSpans() []int <span class="cov8" title="1">{
        result, p := make([]int, len(f.input)), 0
        for i := 0; i &lt; len(f.input); i++ </span><span class="cov8" title="1">{
                for !f.stack.IsEmpty() </span><span class="cov8" title="1">{
                        top, _ := f.stack.Peek()
                        if f.input[i] &gt;= f.input[top.(int)] </span><span class="cov8" title="1">{
                                f.stack.Pop()
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
                <span class="cov8" title="1">if f.stack.IsEmpty() </span><span class="cov8" title="1">{
                        p = -1
                }</span> else<span class="cov8" title="1"> {
                        top, _ := f.stack.Peek()
                        p = top.(int)
                }</span>
                <span class="cov8" title="1">result[i] = i - p
                f.stack.Push(i)</span>
        }
        <span class="cov8" title="1">return result</span>
}

func (f *FindingOfSpans) Execute() <span class="cov8" title="1">{
        f.Result = f.findingSpans()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
        Problem-6/7 How to design a stack such that getMinimum() should be O(1)?
         Take an auxiliary stack that maintains the minimum of all values in the stack. 
         Also, assume that each element of the stack is less than its below elements. 
         For simplicity let us call the auxiliary stack min stack.   
*/

package stack

type GetMinimum struct {
        input  []int
        Result int
}

func NewGetMinimum(input []int) *GetMinimum <span class="cov8" title="1">{
        return &amp;GetMinimum{
                input: input,
        }
}</span>

func (gm *GetMinimum) GetMinimum() int <span class="cov8" title="1">{
        minStack := NewLinkedListStack()

        push := func(i int) </span><span class="cov8" title="1">{
                min, _ := minStack.Peek()
                if minStack.IsEmpty() || min.(int) &gt; i </span><span class="cov8" title="1">{
                        minStack.Push(i)
                }</span>
        }

        <span class="cov8" title="1">for _, i := range gm.input </span><span class="cov8" title="1">{
                push(i)
        }</span>

        <span class="cov8" title="1">min, _ := minStack.Peek()
        return min.(int)</span>
}

func (gm *GetMinimum) Execute() <span class="cov8" title="1">{
        gm.Result = gm.GetMinimum()
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">/*

Problem-2 Infix to postfix conversion algorithm using stack.

Solution: Before discussing the algorithm, first let us see the definitions of infix, prefix and postfix expressions.
        Infix: An infix expression is a single letter, or an operator, proceeded by one infix string and followed by another Infix string.
                A
                A+B
                (A+B)+ (C-D)

        Prefix:  A prefix expression is a single letter, or an operator, followed by two prefix strings.
                        Every prefix string longer than a single variable contains an operator, first operand and second operand.
                A
                +AB
                ++AB-CD

        Postfix: A postfix expression (also called Reverse Polish Notation) is a single letter or an operator, preceded by two postfix strings.
        Every postfix string longer than a single variable contains first and second operands followed by an operator.

                A
                 AB+
                 AB+CD-+

        Algorithm:
                a) Create a stack
                b) for each character t in the input stream{
                                if(t is an operand)
                                        output t
                                else if(t is a right parenthesis){
                                        Pop and output tokens until a left parenthesis is popped (but not output)
                                }
                                else // t is an operator or left parenthesis{
                                        pop and output tokens until one of lower priority than t is encountered or a left  parenthesis is encountered or the
                                        stack is empty
                                        Push t
                                }
                        }
                c) pop and output tokens until the stack is empty
*/

package stack

type InfixToPostFix struct {
        stack  *LinkedListStack
        Input  string
        Result string
}

func NewInfixToPostFix(input string) *InfixToPostFix <span class="cov8" title="1">{
        return &amp;InfixToPostFix{
                stack: NewLinkedListStack(),
                Input: input,
        }
}</span>

func (itp *InfixToPostFix) Convert() string <span class="cov8" title="1">{
        if len(itp.Input) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var result string
        for _, c := range itp.Input </span><span class="cov8" title="1">{
                if itp.isOperator(c) </span><span class="cov8" title="1">{
                        for !itp.stack.IsEmpty() </span><span class="cov8" title="1">{
                                top, _ := itp.stack.Peek()
                                if itp.precedence(top.(rune)) &lt; itp.precedence(c) </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">result += string(top.(rune))
                                itp.stack.Pop()</span>
                        }
                        <span class="cov8" title="1">itp.stack.Push(c)</span>
                } else<span class="cov8" title="1"> if c == '(' </span><span class="cov8" title="1">{
                        itp.stack.Push(c)
                }</span> else<span class="cov8" title="1"> if c == ')' </span><span class="cov8" title="1">{
                        for !itp.stack.IsEmpty() </span><span class="cov8" title="1">{
                                top, _ := itp.stack.Peek()
                                if top.(rune) == '(' </span><span class="cov8" title="1">{
                                        itp.stack.Pop()
                                        break</span>
                                }
                                <span class="cov8" title="1">result += string(top.(rune))
                                itp.stack.Pop()</span>
                        }
                } else<span class="cov8" title="1"> if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') </span><span class="cov8" title="1">{
                        result += string(c)
                }</span>
        }

        <span class="cov8" title="1">for !itp.stack.IsEmpty() </span><span class="cov8" title="1">{
                top, _ := itp.stack.Pop()
                result += string(top.(rune))
        }</span>
        
        <span class="cov8" title="1">return result</span>
}

func (itp *InfixToPostFix) precedence(op rune) int <span class="cov8" title="1">{
        switch op </span>{
        case '+', '-':<span class="cov8" title="1">
                return 1</span>
        case '*', '/':<span class="cov8" title="1">
                return 2</span>
        case '^':<span class="cov8" title="1">
                return 3</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func (itp *InfixToPostFix) isOperator(c rune) bool <span class="cov8" title="1">{
        switch c </span>{
        case '+', '-', '*', '/', '^':<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
        Problem-8
        Given an array of characters formed with a’s and b’s.
        The string is marked with special character X which represents the
        middle of the list (for example: ababa…ababXbabab…..baaa).
        Check whether the string is palindrome.


        Algorithm
        -         Traverse the list till we encounter X as input element.
        -         During the traversal push all the elements (until X) on to the stack.
        -         For the second half of the list, compare each element’s content with top of the stack.
                If they are the same then pop the stack and go to the next element in the input list.
        -         If they are not the same then the given string is not a palindrome.
        -         Continue this process until the stack is empty or the string is not a palindrome.

*/

package stack

type IsPalindromeStack struct {
        stack  *LinkedListStack
        input  string
        Result bool
}

func NewIsPalindromeStack(input string) *IsPalindromeStack <span class="cov8" title="1">{
        return &amp;IsPalindromeStack{
                stack:  NewLinkedListStack(),
                input:  input,
                Result: false,
        }
}</span>

func (obj *IsPalindromeStack) IsPalindrome() bool <span class="cov8" title="1">{
        i := 0
        for index, char := range obj.input </span><span class="cov8" title="1">{
                i = index
                if char == 'X' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">obj.stack.Push(char)</span>
        }
        <span class="cov8" title="1">i++
        inputRune := []rune(obj.input)
        for ; i &lt; len(obj.input); i++ </span><span class="cov8" title="1">{
                ch, err := obj.stack.Pop()
                if err != nil </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">if ch.(rune) != inputRune[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (obj *IsPalindromeStack) Execute() <span class="cov8" title="1">{
        obj.Result = obj.IsPalindrome()
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package stack

import (
        "fmt"
        "golang-dsa/linkedlist"
)

type LinkedListStack struct {
        top    *linkedlist.SingleLinkedList
        length int
}

func NewLinkedListStack() *LinkedListStack <span class="cov8" title="1">{
        return &amp;LinkedListStack{
                top:    nil,
                length: 0,
        }
}</span>

func (stack *LinkedListStack) IsEmpty() bool <span class="cov8" title="1">{
        return stack.top == nil
}</span>

func (stack *LinkedListStack) Size() int <span class="cov8" title="1">{
        return stack.length
}</span>

func (stack *LinkedListStack) Push(data interface{}) <span class="cov8" title="1">{
        node := &amp;linkedlist.SingleLinkedList{
                CustomData: data,
        }
        node.SetNext(stack.top)
        stack.top = node
        stack.length++
}</span>

func (stack *LinkedListStack) Pop() (interface{}, error) <span class="cov8" title="1">{
        if stack.IsEmpty() </span><span class="cov8" title="1">{
                return 0, ErrStackEmpty
        }</span>
        <span class="cov8" title="1">value := stack.top.CustomData
        stack.top = stack.top.GetNext()
        stack.length--
        return value, nil</span>
}

func (stack *LinkedListStack) Peek() (interface{}, error) <span class="cov8" title="1">{
        if stack.IsEmpty() </span><span class="cov8" title="1">{
                return 0, ErrStackEmpty
        }</span>
        <span class="cov8" title="1">return stack.top.CustomData, nil</span>
}

func (stack *LinkedListStack) ToString() string <span class="cov8" title="1">{
        if stack.IsEmpty() </span><span class="cov8" title="1">{
                return "[]"
        }</span>
        <span class="cov8" title="1">var result string
        temp := stack.top

        for temp != nil </span><span class="cov8" title="1">{
                result += fmt.Sprintf(" %+v ", temp.CustomData)
                temp = temp.GetNext()
        }</span>
        <span class="cov8" title="1">return "[" + result + "]"</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
        Problem-4: Discuss postfix evaluation using stacks? 
        Algorithm: 
                1          Scan the Postfix string from left to right. 
                2          Initialize an empty stack. 
                3          Repeat steps 4 and 5 till all the characters are scanned. 
                4          If the scanned character is an operand, push it onto the stack.  
                5          If the scanned character is an operator, and if the operator is a unary operator, then pop an element from the stack. 
                        If the operator is a binary operator, then pop two elements from the stack. After popping the elements, 
                        apply the operator to those popped elements. Let the result of this operation be retVal onto the stack.  
                6          After all characters are scanned, we will have only one element in the stack. 
                7          Return top of the stack as result. 

*/

package stack

type PostFixEvaluation struct {
        stack      *LinkedListStack
        expression string
        Result     int
}

func NewPostFixEvaluation(expression string) *PostFixEvaluation <span class="cov8" title="1">{
        return &amp;PostFixEvaluation{
                stack:      NewLinkedListStack(),
                expression: expression,
        }
}</span>

func (pfe *PostFixEvaluation) Evaluate() int <span class="cov8" title="1">{
        for _, c := range pfe.expression </span><span class="cov8" title="1">{
                if c == '+' </span><span class="cov8" title="1">{
                        op1, _ := pfe.stack.Pop()
                        op2, _ := pfe.stack.Pop()
                        res := op1.(int) + op2.(int)
                        pfe.stack.Push(res)
                }</span> else<span class="cov8" title="1"> if c == '-' </span><span class="cov8" title="1">{
                        op1, _ := pfe.stack.Pop()
                        op2, _ := pfe.stack.Pop()
                        res := op2.(int) - op1.(int)
                        pfe.stack.Push(res)
                }</span> else<span class="cov8" title="1"> if c == '*' </span><span class="cov8" title="1">{
                        op1, _ := pfe.stack.Pop()
                        op2, _ := pfe.stack.Pop()
                        res := op1.(int) * op2.(int)
                        pfe.stack.Push(res)
                }</span> else<span class="cov8" title="1"> if c == '/' </span><span class="cov8" title="1">{
                        op1, _ := pfe.stack.Pop()
                        op2, _ := pfe.stack.Pop()
                        res := op2.(int) / op1.(int)
                        pfe.stack.Push(res)
                }</span> else<span class="cov8" title="1"> {
                        pfe.stack.Push(int(c - '0'))
                }</span>
        }

        <span class="cov8" title="1">result, _ := pfe.stack.Pop()
        return result.(int)</span>
}

func (pfe *PostFixEvaluation) Execute() <span class="cov8" title="1">{
        pfe.Result = pfe.Evaluate()
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package stack

import (
        "errors"
        "fmt"
        "math"
)

const (
        DefaultCapacity = 10
)

var (
        ErrStackEmpty = errors.New("KeyStackEmpty")
        ErrStackFull  = errors.New("KeyStackFull")
)

type FixedSizeArrayStack struct {
        stack    []int
        capacity int
        top      int
}

func NewFixedSizeArrayStack() *FixedSizeArrayStack <span class="cov8" title="1">{
        return &amp;FixedSizeArrayStack{
                stack:    make([]int, DefaultCapacity),
                capacity: DefaultCapacity,
                top:      -1,
        }
}</span>

func NewFixedSizeArrayStackWithCapacity(capacity int) *FixedSizeArrayStack <span class="cov8" title="1">{
        return &amp;FixedSizeArrayStack{
                stack:    make([]int, capacity),
                capacity: capacity,
                top:      -1,
        }
}</span>

func (obj *FixedSizeArrayStack) Size() int <span class="cov8" title="1">{
        return obj.top + 1
}</span>

func (obj *FixedSizeArrayStack) IsEmpty() bool <span class="cov8" title="1">{
        return obj.top &lt; 0
}</span>

func (obj *FixedSizeArrayStack) IsFull() bool <span class="cov8" title="1">{
        return obj.Size() == obj.capacity
}</span>

func (obj *FixedSizeArrayStack) Push(val int) (err error) <span class="cov8" title="1">{
        if obj.IsFull() </span><span class="cov8" title="1">{
                return ErrStackFull
        }</span>
        <span class="cov8" title="1">obj.top++
        obj.stack[obj.top] = val
        return</span>
}

func (obj *FixedSizeArrayStack) Top() (int, error) <span class="cov8" title="1">{
        if obj.IsEmpty() </span><span class="cov8" title="1">{
                return 0, ErrStackEmpty
        }</span>
        <span class="cov8" title="1">return obj.stack[obj.top], nil</span>
}

func (obj *FixedSizeArrayStack) Pop() (int, error) <span class="cov8" title="1">{
        if obj.IsEmpty() </span><span class="cov8" title="1">{
                return 0, ErrStackEmpty
        }</span>
        <span class="cov8" title="1">val := obj.stack[obj.top]
        obj.stack[obj.top] = math.MinInt
        obj.top--
        return val, nil</span>
}

func (obj *FixedSizeArrayStack) ToString() string <span class="cov8" title="1">{
        if obj.IsEmpty() </span><span class="cov8" title="1">{
                return "[]"
        }</span>
        <span class="cov8" title="1">str := fmt.Sprintf("%+v", obj.stack[0])
        for i := 1; i &lt;= obj.top; i++ </span><span class="cov8" title="1">{
                str = fmt.Sprintf("%+v , %+v", str, obj.stack[i])
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[%+v]", str)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
Problem-11
        Given a stack, how to reverse the contents of the stack using only stack operations (push and pop)?
Algorithm
- First pop all the elements of the stack till it becomes empty.
- For each upward step in recursion, insert the element at the bottom of the stack.
*/

package stack

type StackReversal struct {
        stack  *LinkedListStack
        Result []int
}

func NewStackReversal(values []int) *StackReversal <span class="cov8" title="1">{
        stack := NewLinkedListStack()
        for _, value := range values </span><span class="cov8" title="1">{
                stack.Push(value)
        }</span>
        <span class="cov8" title="1">return &amp;StackReversal{
                stack:  stack,
                Result: []int{},
        }</span>
}

func (sr *StackReversal) ReverseStack() <span class="cov8" title="1">{
        temp, err := sr.stack.Pop()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">sr.ReverseStack()
        sr.InsertAtBottom(temp)</span>
}

func (sr *StackReversal) InsertAtBottom(item interface{}) <span class="cov8" title="1">{
        if sr.stack.IsEmpty() </span><span class="cov8" title="1">{
                sr.stack.Push(item)
                return
        }</span>
        <span class="cov8" title="1">temp, _ := sr.stack.Pop()
        sr.InsertAtBottom(item)
        sr.stack.Push(temp)</span>
}

func (sr *StackReversal) Execute() <span class="cov8" title="1">{
        sr.ReverseStack()
        for !sr.stack.IsEmpty() </span><span class="cov8" title="1">{
                item, _ := sr.stack.Pop()
                sr.Result = append(sr.Result, item.(int))
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package stack

import "errors"

var (
        ErrInvalidStackId = errors.New("InvalidStackId")
)

type TwoStackWithOneArray struct {
        stack  []int
        size   int
        topOne int
        topTwo int
}

func NewTwoStackWithOneArray(size int) *TwoStackWithOneArray <span class="cov8" title="1">{
        return &amp;TwoStackWithOneArray{
                stack:  make([]int, size),
                size:   size,
                topOne: -1,
                topTwo: size,
        }
}</span>

func (s *TwoStackWithOneArray) Push(stackId, value int) error <span class="cov8" title="1">{
        if s.topOne+1 == s.topTwo </span><span class="cov8" title="1">{
                return ErrStackFull
        }</span>
        <span class="cov8" title="1">if stackId == 1 </span><span class="cov8" title="1">{
                s.topOne++
                s.stack[s.topOne] = value
        }</span> else<span class="cov8" title="1"> if stackId == 2 </span><span class="cov8" title="1">{
                s.topTwo--
                s.stack[s.topTwo] = value
        }</span> else<span class="cov8" title="1"> {
                return ErrInvalidStackId
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *TwoStackWithOneArray) Pop(stackId int) (int, error) <span class="cov8" title="1">{
        if stackId == 1 </span><span class="cov8" title="1">{
                if s.topOne == -1 </span><span class="cov8" title="1">{
                        return 0, ErrStackEmpty
                }</span>
                <span class="cov8" title="1">value := s.stack[s.topOne]
                s.topOne--
                return value, nil</span>
        } else<span class="cov8" title="1"> if stackId == 2 </span><span class="cov8" title="1">{
                if s.topTwo == s.size </span><span class="cov8" title="1">{
                        return 0, ErrStackEmpty
                }</span>
                <span class="cov8" title="1">value := s.stack[s.topTwo]
                s.topTwo++
                return value, nil</span>
        }
        <span class="cov8" title="1">return 0, ErrInvalidStackId</span>
}

func (s *TwoStackWithOneArray) Peek(stackId int) (int, error) <span class="cov8" title="1">{
        if stackId == 1 </span><span class="cov8" title="1">{
                if s.topOne == -1 </span><span class="cov8" title="1">{
                        return 0, ErrStackEmpty
                }</span>
                <span class="cov8" title="1">return s.stack[s.topOne], nil</span>
        } else<span class="cov8" title="1"> if stackId == 2 </span><span class="cov8" title="1">{
                if s.topTwo == s.size </span><span class="cov8" title="1">{
                        return 0, ErrStackEmpty
                }</span>
                <span class="cov8" title="1">return s.stack[s.topTwo], nil</span>
        }
        <span class="cov8" title="1">return 0, ErrInvalidStackId</span>
}

func (s *TwoStackWithOneArray) IsEmpty(stackId int) bool <span class="cov8" title="1">{
        if stackId == 1 </span><span class="cov8" title="1">{
                return s.topOne == -1
        }</span>
        <span class="cov8" title="1">return s.topTwo == s.size</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
